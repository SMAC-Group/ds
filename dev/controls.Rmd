# Control Flow {#control}

### Cesare 

ddd

Often when we are coding, we need to control the flow of our actions. Just like in daily day to day life, we need to place conditions in which we manipulate our behavior. Statistical programming also fundamentally works in the same way. We program specific behaviors for the program to follow to obtain the statistics that we may need for various tasks like regression and bootstrapping. 

## Logical Operators

Logical operators are used very commonly across all platforms. 

| Command     | Description                |
|-------------|----------------------------|
| x `>` y     | x greater than y           |
| x `>=` y    | x greater or equals to y   |
| x `<` y     | x less than y              |
| x `<=` y    | x less than or equals to y |
| x `==` y    | x equal to y               |
| x `!=` y    | x not equal to y           |
| `!`x        | Not x                      |
| x `| `y     | x or y                     |
| x `&` y     | x and y                    |
| `isTRUE`(x) | test if all of x is TRUE   |

Logical operators can be applied to vectors as well. For example, here we create two random numerical vectors and compare them. 

```{r}
x = c(3,6,3,4,5)
y = c(2,3,4,5,6)
x>y
```

This method outputs a vector of boolean TRUE and FALSE values that perform element-wise comparisons. Note, this is called a vectorized method, which we will further mention in some detail later. `isTRUE()` checks if all the elements within the object is `TRUE`. 

```{r}
isTRUE(TRUE)
isTRUE(x>y)
```

## Control Structures

Control structures allow us to control the flow of code execution. We control the flow of code by using selection controls with logical operators and iterative controls like for-loops. For example, pretend we are trying to build a program that solves a simple maze like the one below. 

<center>![](../images/maze.jpg)</center>

It would be pretty easy to simply draw out the possible solutions with the naked eye. However, if you were actually inside the maze, you would need to narrow your perspective and think of a strategy, like marking paths you have already visited. 

Try to follow the below procedure on the maze above, considering the direction you face while moving. Pretend that you cannot step backward or look behind you. 

- if there is space in front of you, go forward 
- else, if there is space on your right and left, turn right 
- else, if there is only space on your right, turn right 
- else, if there is only space on your left, turn left
- else, [all three sides (forward, left, right) are closed] turn around

Did you escape? Notice the way I structured my solution. Do you see a pattern? Though it might take some time, this way will in turn solve any maze. 

### Selection Controls

Basically if, if/else, if/elseif/else and switch

#### If/else

```{r, eval = FALSE}
if (conditon){
  do something (if condition is TRUE)
}else{
  do something else (if condition is false)
}
```

### Iteration Controls

#### for {#forloop}

(apply methods)

## Applications: 



### Non-parametric Bootstrap

Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour)

```{r}
student_work = c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4)
```

We can compute the mean time spent

```{r}
mean(student_work)
```

*ADD SOMETHING ON T TEST*

```{r}
t.test(student_work)$conf.int
```

We can see that our confidence interval includes a negative values which clearly isn't meaningful. Solution: (non-parametric) bootstrap which works as follows..... ADD SOMETHING

Here is a simple function to implement this approach:


```{r, eval = FALSE, highlight=FALSE}
step 1 do this
step 2 do that
```
```{r}
# Number of boostrap replications
B = 500

# Compute the length of vector
n = length(student_work)

# Confidence level
alpha = 0.05

# Initialisation of 
boot_mean = rep(NA, B)

for (i in 1:B){
  student_work_star = student_work[sample(1:n, replace = TRUE)]
  boot_mean[i] = mean(student_work_star)
}

quantile(boot_mean, c(alpha/2, 1 - alpha/2))
#hist(boot_mean, probability = TRUE)

```

```{r}
n = 10^(2:6)
m = 50
res = matrix(NA, m, length(n))

for (j in 1:length(n)){
  for (i in 1:m){
    set.seed(i)
    x = rnorm(n[j])
    res[i,j] = mean(x)
  }
}

min_range = apply(res, 2, min)
mean_range = apply(res, 2, mean)
max_range = apply(res, 2, max)

plot(mean_range, type = "l", ylim = range(cbind(min_range, max_range)))
lines(min_range)
lines(max_range)
```