[
["data.html", "Chapter 2 Data Structures 2.1 Vectors", " Chapter 2 Data Structures Brievely explain the types of data strucutres in R. Basically there are five Vector: homogenous, 1D Matrix: homogenous, 2D Array: homogenous, nD List: Heterogeneous, 1D Data Frame: Heterogeneous, 2D 2.1 Vectors A vector has three properties: Type, which corresponds the “kind” of objects in contains. Length, i.e. the number of elements in a vector. Attributes, some additional metadata attached to a vector. I think we should make up a story: “we are interested in studying something, you get data”. Let’s store them in R. exp_res = c(1, 2, 3, 5, 1) To display the values stores in exp_res we could simply do: exp_res ## [1] 1 2 3 5 1 Alteratively, we could have create and display the value by using () around the defiition, for example: (exp_res = c(1, 2, 3, 5, 1)) ## [1] 1 2 3 5 1 We can evaluate the kind or type of elements that are stored in a vector using the function typeof(). For example, for the vector we just created we obtain: typeof(exp_res) ## [1] &quot;double&quot; This is a little suprzing as all the elements in exp_res are integers it would seem natural to expect this as an output of the function typeof(). This is R considers by default any number as a “double”, expet when spefiying L after an integer. For example, typeof(1) ## [1] &quot;double&quot; typeof(1L) ## [1] &quot;integer&quot; Therefore, we could express exp_res as follows: (exp_res_int = c(1L, 2L, 3L, 5L, 1L)) ## [1] 1 2 3 5 1 typeof(exp_res_int) ## [1] &quot;integer&quot; Naturally, the difference is the two in general relatively but we can see that exp_res_int takes less “space” to two. For example, we have object.size(exp_res) ## 88 bytes object.size(exp_res_int) ## 72 bytes 2.1.1 Subsetting Naturally, it is possible to “subset” the values of in our vectror in many ways. Essentially, there are four main ways of subsetting a vector. Here we’ll only discuss the first three: Positive Index: We can access or subset the \\(i\\)-th element of a vector by simply using exp_res[i] where \\(i\\) is a positive number between 1 and length of the vector. # Accesing the first element exp_res[1] ## [1] 1 # Accesing the third and first value exp_res[c(3, 1)] ## [1] 3 1 # Duplicated indices yield duplicated values exp_res[c(1, 1, 2, 2, 3, 4)] ## [1] 1 1 2 2 3 5 Negative Index: We remove elements in a vector using negative indices: # Removing the second obervation exp_res[-2] ## [1] 1 3 5 1 # Removing the first and fourth obserations exp_res[c(-1, -4)] ## [1] 2 3 1 Logical Indices: Another usefull approach is based on logic al operators: # Access the first and fourth observations exp_res[c(TRUE, FALSE, FALSE, TRUE, FALSE)] ## [1] 1 5 ADD REMARK BOX Here we could add some remarks on weird cases, for example exp_res[c(1.2, 3.4)] (which rounds things up) or exp_res[c(-1, 2)] (which doesn’t work as “mixed” indices are not permitted). 2.1.2 Attributes Our experiment was conducted under specific conditions, say a date and a place which should be store are attributes. Indeed, objects can have arbitrary additional attributes, used to store metadata about the considered object. For example: attr(exp_res, &quot;date&quot;) = &quot;07-21-2017&quot; attr(exp_res, &quot;location&quot;) = &quot;Montreux, Switzerland&quot; To display the vector with its attributes exp_res ## [1] 1 2 3 5 1 ## attr(,&quot;date&quot;) ## [1] &quot;07-21-2017&quot; ## attr(,&quot;location&quot;) ## [1] &quot;Montreux, Switzerland&quot; To only display the attributes attributes(exp_res) ## $date ## [1] &quot;07-21-2017&quot; ## ## $location ## [1] &quot;Montreux, Switzerland&quot; It is also possible to extract a specific attribute attr(exp_res, &quot;date&quot;) ## [1] &quot;07-21-2017&quot; 2.1.3 Application: Non-parametric bootstrap Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour) student_work = c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4) We can compute the mean time spent mean(student_work) ## [1] 0.825 ADD SOMETHING ON T TEST t.test(student_work)$conf.int ## [1] -0.03495865 1.68495865 ## attr(,&quot;conf.level&quot;) ## [1] 0.95 We can see that our confidence interval includes a negative values which clearly isn’t meaningful. Solution: (non-parametric) bootstrap which works as follows….. ADD SOMETHING Here is a simple function to implement this approach: # Number of boostrap replications B = 500 # Compute the length of vector n = length(student_work) # Confidence level alpha = 0.05 # Initialisation of boot_mean = rep(NA, B) for (i in 1:B){ student_work_star = student_work[sample(1:n, replace = TRUE)] boot_mean[i] = mean(student_work_star) } quantile(boot_mean, c(alpha/2, 1 - alpha/2)) ## 2.5% 97.5% ## 0.300000 1.613125 #hist(boot_mean, probability = TRUE) "]
]
