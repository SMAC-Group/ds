# R Packages



Suppose we have the following two function, and would like to construct a package containing these functions:

```{r}
mc_int = function(x_range, fun, B, seed = 1291){
  # A few checks
  # Check x_range
  if (length(x_range) != 2 || x_range[1] >= x_range[2]){
    stop("x_range is incorrectly specified")
  }

  # Check fun
  if (class(fun) != "character"){
    stop("fun is incorrectly specified and should be a character")
  }

  x = mean(x_range)
  test_fun = try(eval(parse(text = fun)), silent = TRUE)
  if (class(test_fun) == "try-error"){
    stop("fun cannot be evaluated")
  }

  # Check B
  if (B < 1){
    error("B is incorrectly specified")
  }

  # Set seed
  set.seed(seed)

  # Compute the length of the interval, i.e. (b-a)
  interval_length = diff(x_range)

  # Let's draw some uniforms to get Ui and Xi
  Ui = runif(B)
  Xi = x_range[1] + Ui*interval_length

  # Compute \hat{I}
  x = Xi
  I_hat = interval_length*mean(eval(parse(text = fun)))

  # Compute \hat{I}_2
  I2_hat = interval_length*mean((eval(parse(text = fun)))^2)
  var_I_hat = (interval_length*I2_hat - I_hat^2)/B

  # Output list
  out = list(I = I_hat, var = var_I_hat,
             fun = fun, x_range = x_range, B = B)
  class(out) = "MCI"
  out
}

plot.MCI = function(x, ...){
  obj = x
  x_range = obj$x_range
  fun = obj$fun

  Delta = diff(x_range)
  x_range_graph = c(x_range[2] - 1.15*Delta, x_range[1] + 1.15*Delta)
  x = seq(from = x_range_graph[1], to = x_range_graph[2], length.out = 10^3)
  f_x = eval(parse(text = fun))
  plot(NA, xlim = range(x), ylim = range(f_x), xlab = "x", ylab = "f(x)")
  grid()
  title(paste("Estimated integral: ", round(obj$I,4),
              " (", round(sqrt(obj$var),4),")", sep = ""))
  lines(x, f_x)
  x = seq(from = x_range[1], to = x_range[2], length.out = 10^3)
  f_x = eval(parse(text = fun))
  cols = hcl(h = seq(15, 375, length = 3), l = 65, c = 100, alpha = 0.4)[1:3]
  polygon(c(x, rev(x)), c(rep(0, length(x)), rev(f_x)),
          border = NA, col = cols[1])
  abline(v = x_range[1], lty = 2)
  abline(v = x_range[2], lty = 2)
}
```

The package will contain `mc_int()`, a function that computes an approximation of the integral of the function f(x) with respect to dx in the range [a, b] by Monte-Carlo integration using uniform sampling, and `plot.MCI()`, a class function that will plot the object that is created above. 

An example of these functions in action would be

```{r}
obj = mc_int(x_range = c(0,1), fun = "x^2*sin(x^2/pi)", B = 10^3)
plot(obj)
```


## Basic steps

Below will be the basic steps of creating a package. This process is not strict, since there are many different ways of structuring and building a from scratch. However, in this book, we will use this structure as the standard. 

### Step 1: Create an "empty" R package

The first step of creating a package will be through RStudio. Follow the steps from the images below to create a basic package skeleton. 

<center>
![](images/part1_1.png)
</center>

<center>
![](images/part1_2.png)
</center>

<center>
![](images/part1_3.png)
</center>

Here we can name our package. Make sure it is relevant to our goals and objectives. In this example, we will call it `demo`. 

<center>
![](images/part1_4.png)
</center>

Once this procedure is complete, our window should look similar to this

<center>
![](images/part2_1.png)
</center>

Remove the following files before proceeding:

- NAMESPACE
- man/hello.Rd
- R/hello.R

These are default functions/documentation that exist to guide us, but will eventually hinder our future objectives. 

### Step 2: Edit description file

Another essential part of the package is the DESCRIPTION file. This contains different parts that provides a description for the package, such as the package name, type, title, version, date, author information, explanation, dependencies, license, and imports. 

#### Author Roles {-}

Authors are usually written in this format:

```{r, eval = FALSE}
Authors@R: c(
    person("Justin", "Lee", email = "justinlee@psu.edu", role = c("aut","cre")),
    person("Stephane", "Guerrier", role = "aut"),
    person("Roberto", "Molinari", role = "aut"),
    person("Matthew", "Beckman", role = "aut")
    )
```

Feel free to add or subtract any information above, as they will impact how it is displayed later in the rendered package website. The `aut` above represents *author* and the `cre` represents *creator*. 

#### License {-}

The most common license is the GNU General Public License, which is a widely used free software license that guarantees end users the freedom to run, study, share and modify the software. We can run through this [list](https://cran.r-project.org/web/licenses/) and choose the license that fits our needs. 

#### Imports {-}

Imports are also essential for building a package. For every function that we use from an external package, we either need to add a dependency or import, or our package will not know where to locate the function. Make sure to double check. 

### Step 3: Move your script into R file in R folder

Once we have the tasks completed above, we need to start writing the *meat* portion of our package: the functions. First, group functions together per theme in different files. In other words, if we have functions that perform different tasks, we should group them into different R files so that we can come back to them to fix any errors. Packages can still work under a single R file, but things will get messy once we add more and more functions. 

We can test our `.R` files by running each file seperately using `source('~/demo/R/<name of your file>.R')` and eventually debug if any error occurs.

### Step 4: Documentation

The next essential factor of a package is its documentation, and is one of the most important aspects. Documentation enables users to know how to use our package. Essentially, when users use the `demo` package, they should know how to use its functions as well like `?mc_int`. The most common form of R package documentation is generating `.Rd` files by using `devtools::document()` or `roxygen2::roxygenize`.

Here is an example of documentation for our `demo` funtions:

```{r, eval = FALSE}
#' @title Simple Monte-Carlo integration
#'
#' @description Compute an approximation of the integral of the function f(x)
#' with respect to dx in the range [a, b] by Monte-Carlo integration using
#' uniform sampling.
#' @param x_range A \code{vector} of dimension 2 used to denote the integration
#' region of interest, i.e. [a, b].
#' @param fun A \code{string} containing the function to integrated. It
#' is assumed that \code{x} is used as the variable of interest.
#' @param B A \code{numeric} (integer) used to denote the number of simulation.
#' @param seed A \code{numeric} used to control the seed of the random number
#' generated by this function.
#' @return A \code{list} containing the following attributes:
#' \describe{
#'      \item{I}{Estimated value of the integral}
#'      \item{var}{Estimated variance of the estimator}
#' }
#' @author Stephane Guerrier
#' @importFrom stats runif
#' @export
#' @examples
#' mc_int(x_range = c(0,1), fun = "x^2", B = 10^5)
#' mc_int(x_range = c(0,1), fun = "x^2*sin(x^2/pi)", B = 10^5)
mc_int = function(x_range, fun, B, seed = 1291){
  # A few checks
  # Check x_range
  if (length(x_range) != 2 || x_range[1] >= x_range[2]){
    stop("x_range is incorrectly specified")
  }

  # Check fun
  if (class(fun) != "character"){
    stop("fun is incorrectly specified and should be a character")
  }

  x = mean(x_range)
  test_fun = try(eval(parse(text = fun)), silent = TRUE)
  if (class(test_fun) == "try-error"){
    stop("fun cannot be evaluated")
  }

  # Check B
  if (B < 1){
    error("B is incorrectly specified")
  }

  # Set seed
  set.seed(seed)

  # Compute the length of the interval, i.e. (b-a)
  interval_length = diff(x_range)

  # Let's draw some uniforms to get Ui and Xi
  Ui = runif(B)
  Xi = x_range[1] + Ui*interval_length

  # Compute \hat{I}
  x = Xi
  I_hat = interval_length*mean(eval(parse(text = fun)))

  # Compute \hat{I}_2
  I2_hat = interval_length*mean((eval(parse(text = fun)))^2)
  var_I_hat = (interval_length*I2_hat - I_hat^2)/B

  # Output list
  out = list(I = I_hat, var = var_I_hat,
             fun = fun, x_range = x_range, B = B)
  class(out) = "MCI"
  out
}
```

All functions you want to be able to use MUST have `#' @export`. This enables the users to call the function after building the package. Other parts of the documentation can be further seen from [here](http://r-pkgs.had.co.nz/man.html#man-functions). 

<center>
![Example .Rd files created after documentation](images/part5_1.png)
</center>

After, build documentation by using `devtools::document()`. If everyhting is working properly, we should have one Rd document for everything function that is exported within the package. Check by using `?yourfunction`.

<center>
![Output when running ?mc_int](images/part5_2.png)
</center>

### Step 5: Test your package

- Build your package - part6-1
- Test if it works - by creating a "test" file in main and run everything it you change something major to the package to see if the behavious remains unchanged. -> part6-2

<center>
![](images/part6_1.png)
</center>

<center>
![](images/part6_2.png)
</center>

- Run check

### Step 6: Add a "README.Rmd" file

Showcase what your package is doing in this RMD file, you can add video, code example,....


```{eval=FALSE}
---
output: github_document
---

# Add a title
  
Explain what your package is doing here
```

Compile it with pkgdown (install: `devtools::install_github("hadley/pkgdown")`): `pkgdown::build_site()`

Result should look like: part7 - 1

<center>
![](images/part7_1.png)
</center>


### Step 7: Create a github repo - possibly with the same name as package

- Sync should look like:

<center>
![](images/part8_1.png)
</center>

Make website -> github page

<center>
![](images/part8_2.png)
</center>

Then your website is only... The address is `https://<your github id>.github.io/<your repo name>/`

## Advanced

### Adding a shiny app

- make folder called `inst`
- In `inst` put shiny app folder
- Make r file call it, called it for example `run_shiny.r`, here is an example:

```{r, eval = FALSE}
#' @export
MC_gui = function(){
  appDir = system.file("MC_int", package = "demo")
  shiny::runApp(appDir, display.mode = "normal")
}
```

- Run: `devtools::document()` + rebuild
- Test: `MC_gui()`

<center>
![](images/adv_1.png)
</center>

### Custom website

Justin to do, theme , badge, tabs,....


EXAMPLE: smac-group/demo



