```{r setup, cache = F, echo=F}
knitr::opts_chunk$set(error = TRUE)
```

# Shiny

Shiny is an R package that makes it easy to build interactive web apps straight from R. 

## Introduction 

Before building the application, we want to know to build our application, and think more like a software engineer. We want to take some input, such as parameters, and produce output. In this chapter we will build the shiny applicaion building procedure. 

### Step 1. R Code / Server / Backend

Before we start thinking of the web application, we want to focus on the R Code, or also commonly known as the "backend" of the application. For all the intended operations to work in the application we need to make sure that the R code that serves as the skeleton operates in the way the developer want it to be. 

For example, perhaps we are trying to build an application that builds a histogram from the waiting time of the default R dataset, Old Faithful Geyser Dataset. We also want to add an option for controlling the number of bins. 

For this to work, we want to build the histogram in R and test out to see if the output is what was desired initially. Below we create the default histogram. 

```{r}
x <- faithful[, 2] 
hist(x)
```

Now we want to make sure to later add the option of creating more bins so the graph is customizable. In the `hist()` function, we see an option `breaks` that we can use to take in different inputs based on what the client wants. 

```{r}
par(mfrow = c(1,2))

# Compare the differences! 
bins <- seq(min(x), max(x), length.out = 10)
hist(x, breaks = bins)

bins <- seq(min(x), max(x), length.out = 20)
hist(x, breaks = bins)
```

### Step 2: User Interface (UI) / Frontend 

The previous information goes into a part called the "server" in the shiny application. Now we want to focus on the frontend of the application, the things we "see" and options we can interact with when we open the app. 

#### Content Creation 

We want to design what the application so that it is comprehensive and easy to interpret. Below are some often used options of content creation that will be beneficial to know. 

| Function        | Description                              |
|-----------------|------------------------------------------|
| titlePanel()    | The title of the application             |
| sidebarLayout() | Creates a sidebar layout for fluidPage() |

#### Input Controls

We also want to provide space so the client can change any desired parameter. In the example explained above, this would be the number of bins. Below are some input controls the developer can use.

| Function        | Description               |
|-----------------|---------------------------|
| numericInput()  | Number entry input        |
| radioButtons()  | Radio button selection    |
| selectInput()   | Dropdown menu             |
| sliderInput()   | Range slider (1/2 values) |
| submitButton()  | Submission button         |
| textInput()     | Text input box            |
| checkboxInput() | Single checkbox input     |
| dateInput()     | Date Selection input      |
| fileInput()     | Upload a file to Shiny    |
| helpText()      | Describe input field      |


| sidebarPanel()  | Makes a sidebar menu                     |
| mainPanel()     | Main content area for different output   |

#### Output Render Controls 

The different type of output that is shown can be designed depending on what the developer intends it to be. Examples of these options are shown below. We advise you to follow the videos and research different options that fit the desired output. 

| Function             | Description             |
|----------------------|-------------------------|
| plotOutput()         | Display a rendered plot |
| tableOutput()        | Display in Table        |
| textOutput()         | Formatted Text Output   |
| uiOutput()           | Dynamic UI Elements     |
| verbatimTextOutput() | "as is"" Text Output"   |
| imageOutput()        | Render an Image         |
| htmlOutput()         | Render Pure HTML        |

### Step 3: Connecting frontend and backend 






## Example: Buffon's needle

In 1777, the French nobleman Georges-Louis Leclerc, Compte de Buffon posed the following problem to the Royal Academy of Sciences in Paris [@buffon1777essai]:

> Suppose that you drop a needle of unit length on a plane ruled by the lines $y = m \; (m = 0, \pm 1, \pm 2, ...)$ - what is then the probability that the needle comes to lie in a position where it crosses one of the lines?

Compte de Buffon also provided the answer and showed that the needle will intersect lines with a predictable probability. In mathematical terms, his solution (still known today as the Buffon principle) can be stated as follows:

\begin{equation} 
\mathbb{P}(\text{intersection}) = \frac{2}{\pi}.
(\#eq:probbuffon)
\end{equation} 

If you are curious about the derivation of this result, click on the button below.

<button id="hidebutton2">Derivation - Equation (7.1)</button>
<div id="hideclass2">
```{block2, type='rmdtip'}
This proof is based on the solution of Example 4.5.8 of @grimmett2001probability. We start by letting the point $(X, Y)$ denote the coordinates of the center of the needle and let $\Theta$ be the angle, modulo $\pi$, made by the needle and the horizontal axis. Next, we define the distance from the needle's center to the nearest line beneath it by $Z = Y -  \lfloor Y \rfloor$, where $\lfloor Y \rfloor$ denotes the "floor" of $Y$, i.e. the greatest integer not greater than $Y$. Since the needle is randomly casted we have that the joint density of $(Z, \Theta)$ is given by:

\[
f_{Z, \Theta} (z, \theta) = f_{Z} (z) f_{\Theta} (\theta) = \frac{1}{\pi},
\]

for $0 \leq z \leq 1$ and $0 \leq \theta \leq \pi$. By drawing a diagram one can see that an interception occurs if and only if $(Z, \Theta) \in \mathcal{B}$, where

\[
\mathcal{B} = \left\{(z, \theta)\,: \;\; z \leq \frac{1}{2} \sin (\theta)  \;\; \text{or} \;\; 1-z \leq \frac{1}{2} \sin(\theta)\right\}.
\]

Therefore, we obtain

\[
\mathbb{P}(\text{intersection}) = \iint_\mathcal{B} \; f_{Z, \Theta} (z, \theta)\, dz \, d\theta = \frac{1}{\pi} \int_0^\pi \left(\int_0^{\frac{1}{2}\sin(\theta)} dz + \int_{1 - \frac{1}{2}\sin(\theta)}^{1} dz \right) d\theta = \frac{2}{\pi},
\]

which verifies Equation \@ref(eq:probbuffon) and concludes the proof.
```
</div>
\newline

Georges-Louis Leclerc motivation behind this problem was to design an experiment to estimate the value of $\pi$. Indeed, if you fling a needle a large number $n$ times onto a ruled plane and count the number of times $S_n$ that the needle intersects a line we might be able to approximate $\mathbb{P}(\text{intersection})$ and therefore $\pi$. From Equation \@ref(eq:probbuffon), we know that the proportion $S_n/n$ will be "close" to the probability $\mathbb{P}(\text{intersection})$. In fact the (weak) law of large number garantees that $S_n/n$ converges (in probability) to $2/\pi$, i.e. for any given $\varepsilon > 0$,

\[
\lim_{n \rightarrow \infty} \; \mathbb{P}\left( \left| \frac{S_n}{n} - \frac{2}{\pi} \right|  > \varepsilon \right) = 0.
\]

Thus, the estimator

\[
\hat{\pi} = \frac{2n}{S_n},
\]

is a plausible estimator of $\pi$. The Continous Mapping Theorem [see e.g. Theorem 1.14 of @dasgupta2008asymptotic] can (among other) be used to show that $\hat{\pi}$ is a **consistent** estimator of $\pi$ (i.e. $\hat{\pi}$ converges in probability to $\pi$). In 1777, Georges-Louis Leclerc investigated this problem and computed $\hat{\pi}$ by flipping a coin 2084 times, which may consitute the first recorded example of a Monte-Carlo method (simulation?) in use.


INTRO HERE


In the function below, we cast a needle:

```{r}
cast_needle = function(plan = 10, needle_length = 1){
  available_range = plan - needle_length
  x_start = runif(2, -available_range, available_range)
  angle = runif(1, 0, 2*pi)
  x_end = needle_length*c(cos(angle), sin(angle)) + x_start
  cross = floor(x_start[2]) != floor(x_end[2])
  out = list(start = x_start, end = x_end, cross = cross)
  out
}
```

Next, let's do many and compute $\hat{\pi}$:

```{r}
buffon_needle = function(B = 2084, plan = 10, needle_length = 1, seed = NULL){
  
  if (!is.null(seed)){
    set.seed(seed)
  }
  
  X_start = X_end = matrix(NA, B, 2) 
  cross = rep(NA, B)
  for (i in 1:B){
    inter = cast_needle(plan = plan, needle_length = needle_length)
    X_start[i, ] = inter$start
    X_end[i, ] = inter$end
    cross[i] = inter$cross
  }
  out = list(start = X_start, end = X_end, cross = cross, plan = plan)
  class(out) = "buffon_needle"
  out
}
```

Let's construct a plot function: 

```{r}
plot.buffon_needle = function(obj){
  cross = obj$cross
  X_start = obj$start
  X_end = obj$end
  B = length(cross)
  cols = rev(hcl(h = seq(15, 375, length = 3), l = 65, c = 100)[1:2])
  
  titre_part1 = 'Buffon\'s needle experiment  -  '
  titre_part2 = ' = '
  pi_hat = round(2/mean(obj$cross), 6)
  
  titre = bquote(.(titre_part1) ~ hat(pi) ~ .(titre_part2) ~ .(pi_hat))
  
  plot(NA, xlab = "x", ylab = "y", xlim = c(-obj$plan, obj$plan), 
       ylim = c(-obj$plan, obj$plan), 
       main = titre)
  abline(h = (-obj$plan):obj$plan, lty = 3)
  
  for (i in 1:B){
    lines(c(X_start[i,1], X_end[i,1]), c(X_start[i,2], X_end[i,2]), 
          col = cols[cross[i] + 1])
  }
}
```

This looks like:

```{r, fig.align='center', fig.width=5, fig.height=5.2}
experiment = buffon_needle()
plot(experiment)
```

Finally, we can illustarte the converge in prob

```{r}
converge = function(B = 2084, plan = 10, needle_length = 1, seed = 1777, M = 12){
  
  if (B < 10){
    warning("B was changed to 10")
    B = 10
  }
  pi_hat = matrix(NA, B, M)
  trials = 1:B
  cols = rev(hcl(h = seq(15, 375, length = (M+1)), l = 65, c = 100, alpha = 1)[1:M])
  
  set.seed(seed)
  
  for (i in 1:M){
    cross = buffon_needle(B = B, plan = plan, needle_length = needle_length)$cross
    pi_hat[,i] = 2*trials/cumsum(cross)
  }
  
  
  plot(NA, xlim = c(1,B), ylim = pi + c(-3/4, 3/4), type = "l", col = "darkblue",
       ylab = bquote(hat(pi)[i]),
       xlab = "i", main = "Buffon\'s needle experiment in time")
  grid()
  
  for (i in 1:M){
    lines(trials, pi_hat[,i], col = cols[i])
  }
  
  abline(h = pi, lwd = 2, lty = 2)
}
```


```{r, fig.align='center', fig.width=6, fig.height=5.2}
converge(B = 5*10^4, M = 4, seed = 10)
```


What we want:

- inputs
- 2 tabs
- buttom to draw + update seed

<center>
![](images/buffon.png)
</center>




<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript">
    $("#hideclass1").hide();
    $("#hideclass2").hide();
    $("#hidebutton1").click(function(){
      $("#hideclass1").toggle();
    });
    $("#hidebutton2").click(function(){
      $("#hideclass2").toggle();
    });
</script>
