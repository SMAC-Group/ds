[
["index.html", "Let’s find a good title Chapter 1 Introduction", " Let’s find a good title Matthew Beckman, Stéphane Guerrier, Justin Lee &amp; Roberto Molinari 2017-07-29 Chapter 1 Introduction Explain what this text is about + objectives. This chapter should summarize the advantage of using R. Following Hadley’s Advanced R, here are the main points: Free, open source which implies easy results can easily be replicated. Massive set of packages Easy packages creation to allow code sharing Cutting edge tools (research in stat and machine learning often use R) Powerful tools for communicating results (Rmarkdown, shinny) Can be “connected” to high-performance languages. In this text, we will discuss C++ but C and FORTRAN are also natural candidates Maybe add drawback of R, for me the main one is that R is slow and doesn’t manages well memory. There are certainly other just as the inconsistency between packages. It would be nice to add some kind of list of “what you should be able to do after reading this text”. Finally, a few remarks on conventions, references (this text will use a lot Hadley’s books) and some acknowledgements. "],
["data.html", "Chapter 2 Data Structures 2.1 Vectors 2.2 Matrix 2.3 Array 2.4 List 2.5 Dataframe 2.6 Data frames", " Chapter 2 Data Structures &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Briefly explain the types of data strucutres in R. Basically there are five ======= There are different data types that are commonly used in R among which the most important ones are the following: &gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master Numeric (or double): these are used to store real numbers. Examples: -4, 12.4532, 6. Integer: examples: 2L, 12L. Logical (or boolean): examples: TRUE, FALSE. Character: examples: &quot;a&quot;, &quot;Bonjour&quot;. In R there are basically five types of data structures in which elements can be stored. A data structure is said to homogeneous if it only contains elements of the same type (for example it only contains character or numeric values) and heterogenous if it contains elements of more than one type. The five types of data structrures are commonly summarized in a table similar to the one below: Dimension Homogenous Heterogeneous 1 Vector List 2 Matrix Dataframe n Array To illustrate how to use these data structures, we will consider the simple data set of the five best male single tennis players (as ranked by ATP on 07-15-2017). The data are presented in the table below: Name Date of Birth Born Country ATP Ranking Prize Money Win Percentage Grand Slam Wins Andy Murray 15 May 1987 Glasgow, Scotland Great Britain 1 60,449,649 78.07 9 Rafael Nadal 3 June 1986 Manacor, Spain Spain 2 85,920,132 82.48 15 Stan Wawrinka 28 March 1985 Lausanne, Switzerland Switzerland 3 30,577,981 63.96 5 Novak Djokovic 22 May 1987 Belgrade, Serbia Serbia 4 109,447,408 82.77 12 Roger Federer 8 August 1981 Basel, Switzerland Switzerland 5 104,445,185 81.80 18 It can be noticed that this data set contains columns with a variety of data types and in the next sections we will focus on these different types separately. 2.1 Vectors A vector has three important properties: Type, which corresponds the “kind” of objects in contains. It is possible to use the function typeof() to evaluate the type of objects in a vector. Length, i.e. the number of elements in a vector. This information can be obtained using the function length(). Attributes, some additional metadata attached to a vector. The functions attr() and attributes() can be used to store and retrive attributes (more details can be found in Section 2.1.4) For example, let us consider the number of grand slams won by the five players we are considering which are reported in the eigth column of the dataset: grand_slam_win = c(9, 15, 5, 12, 18) To display the values stored in grand_slam_win we could simply enter the following in the R console: grand_slam_win ## [1] 9 15 5 12 18 Alteratively, we could have created and displayed the value by using () around the definition of the object itself as follows: (grand_slam_win = c(9, 15, 5, 12, 18)) ## [1] 9 15 5 12 18 Various forms of “nested concatenation” can be used to defined vectors, for example we could also define grand_slam_win as (grand_slam_win = c(9, c(15, 5, c(12, c(18))))) ## [1] 9 15 5 12 18 This approach is often used to assemble vectors in various ways. It is also possible to define vector with characters, for example we could define a vector with the player names as follows: (players = c(&quot;Andy Murray&quot;, &quot;Rafael Nadal&quot;, &quot;Stan Wawrinka&quot;, &quot;Novak Djokovic&quot;, &quot;Roger Federer&quot;)) ## [1] &quot;Andy Murray&quot; &quot;Rafael Nadal&quot; &quot;Stan Wawrinka&quot; &quot;Novak Djokovic&quot; ## [5] &quot;Roger Federer&quot; 2.1.1 Type We can evaluate the kind or type of elements that are stored in a vector using the function typeof(). For example, for the vectors we just created we obtain: typeof(grand_slam_win) ## [1] &quot;double&quot; typeof(players) ## [1] &quot;character&quot; This is a little surprising as all the elements in grand_slam_win are integers and it would therefore seem natural to expect this as an output of the function typeof(). This is because R considers any number as a “double” by default, except when adding the suffix L after an integer. For example: typeof(1) ## [1] &quot;double&quot; typeof(1L) ## [1] &quot;integer&quot; Therefore, we could express grand_slam_win as follows: (grand_slam_win_int = c(9L, 15L, 5L, 12L, 18L)) ## [1] 9 15 5 12 18 typeof(grand_slam_win_int) ## [1] &quot;integer&quot; Naturally, the difference between the two in general is relatively unimportant but we can see that grand_slam_win_int takes less “space” among the two. Indeed we have object.size(grand_slam_win) ## 88 bytes object.size(grand_slam_win_int) ## 72 bytes 2.1.2 Coercion As indicated earlier, a vector has a homogenous data structure meaning that it can only contain a single type among all the data types. Therefore, when more than one data type is provided, R coerces the data into a “shared” type. To identify this “shared” type we can use this simple rule: \\[\\begin{equation*} \\text{logical} &lt; \\text{integer} &lt; \\text{numeric} &lt; \\text{character}, \\end{equation*}\\] which simply means that if a vector contains more than one data type, the “shared” type will be that of the “largest” type according to the above equations. Here are a few examples: # Logical + integer (mix_logic_int = c(TRUE, 1L)) ## [1] 1 1 typeof(mix_logic_int) ## [1] &quot;integer&quot; # Logical + character (mix_logic_char = c(TRUE, &quot;Hi&quot;)) ## [1] &quot;TRUE&quot; &quot;Hi&quot; typeof(mix_logic_char) ## [1] &quot;character&quot; # Integer + numeric (mix_int_num = c(1, 1L)) ## [1] 1 1 typeof(mix_int_num) ## [1] &quot;double&quot; # Integer + character (mix_int_char = c(1L, &quot;Hi&quot;)) ## [1] &quot;1&quot; &quot;Hi&quot; typeof(mix_int_char) ## [1] &quot;character&quot; 2.1.3 Subsetting Naturally, it is possible to “subset” the values of in our vectror in many ways. Essentially, there are four main ways of subsetting a vector. Here we’ll only discuss the first three: Positive Index: We can access or subset the \\(i\\)-th element of a vector by simply using grand_slam_win[i] where \\(i\\) is a positive number between 1 and length of the vector. # Accesing the first element grand_slam_win[1] ## [1] 9 # Accesing the third and first value grand_slam_win[c(3, 1)] ## [1] 5 9 # Duplicated indices yield duplicated values grand_slam_win[c(1, 1, 2, 2, 3, 4)] ## [1] 9 9 15 15 5 12 Negative Index: We remove elements in a vector using negative indices: # Removing the second obervation grand_slam_win[-2] ## [1] 9 5 12 18 # Removing the first and fourth obserations grand_slam_win[c(-1, -4)] ## [1] 15 5 18 Logical Indices: Another usefull approach is based on logical operators: # Access the first and fourth observations grand_slam_win[c(TRUE, FALSE, FALSE, TRUE, FALSE)] ## [1] 9 12 Here we could add some remarks on weird cases, for example grand_slam_win[c(1.2, 3.4)] (which rounds things up) or grand_slam_win[c(-1, 2)] (which doesn’t work as “mixed” indices are not permitted). 2.1.4 Attributes Let’s suppose that we conducted an experiment under specific conditions, say a date and a place which should be stored as attributes of the object containing the results of this experiment. Indeed, objects can have arbitrary additional attributes that are used to store metadata on the object of interest. For example: attr(grand_slam_win, &quot;date&quot;) = &quot;07-15-2017&quot; attr(grand_slam_win, &quot;type&quot;) = &quot;Men, Single&quot; To display the vector with its attributes grand_slam_win ## [1] 9 15 5 12 18 ## attr(,&quot;date&quot;) ## [1] &quot;07-15-2017&quot; ## attr(,&quot;type&quot;) ## [1] &quot;Men, Single&quot; To only display the attributes we have attributes(grand_slam_win) ## $date ## [1] &quot;07-15-2017&quot; ## ## $type ## [1] &quot;Men, Single&quot; It is also possible to extract a specific attribute attr(grand_slam_win, &quot;date&quot;) ## [1] &quot;07-15-2017&quot; 2.1.5 Adding labels In some cases it might be useful to add labels to vectors. For example, we could define the vector grand_slam_win and use the player’s names as labels, i.e. (grand_slam_win = c(&quot;Andy Murray&quot; = 9, &quot;Rafael Nadal&quot; = 15, &quot;Stan Wawrinka&quot; = 5, &quot;Novak Djokovic&quot; = 12, &quot;Roger Federer&quot; = 18)) ## Andy Murray Rafael Nadal Stan Wawrinka Novak Djokovic Roger Federer ## 9 15 5 12 18 The main advantage of this approach is that the number of grand slams won can now be referred to by the player’s name. For example: grand_slam_win[&quot;Andy Murray&quot;] ## Andy Murray ## 9 grand_slam_win[c(&quot;Andy Murray&quot;,&quot;Roger Federer&quot;)] ## Andy Murray Roger Federer ## 9 18 All labels (players’ names in our case) can be obtained witht the function names, i.e. names(grand_slam_win) ## [1] &quot;Andy Murray&quot; &quot;Rafael Nadal&quot; &quot;Stan Wawrinka&quot; &quot;Novak Djokovic&quot; ## [5] &quot;Roger Federer&quot; 2.1.6 Useful functions with vectors The reason for extracting or creating vectors often lies in the need to collect information from them. For this purpose, a series of useful functions are available that allow to extract information or arrange the vector elements in a certain manner which can be of interest to the user. Among the most commonly used functions we can find the following ones length() sum() mean() sort() and order() whose name is self-explicative in most cases. For example we have length(grand_slam_win) ## [1] 5 sum(grand_slam_win) ## [1] 59 mean(grand_slam_win) ## [1] 11.8 To sort the players by number of grand slam wins, we could use the function order() which returns the position of the elements of a vector sorted in an ascending order, order(grand_slam_win) ## [1] 3 1 4 2 5 Therefore, we can sort the players in ascending order of wins as follows players[order(grand_slam_win)] ## [1] &quot;Stan Wawrinka&quot; &quot;Andy Murray&quot; &quot;Novak Djokovic&quot; &quot;Rafael Nadal&quot; ## [5] &quot;Roger Federer&quot; which implies that Roger Federer won most grand slams. Another related function is sort() which simply sorts the elements of a vector in an ascending manner. For example, sort(grand_slam_win) ## Stan Wawrinka Andy Murray Novak Djokovic Rafael Nadal Roger Federer ## 5 9 12 15 18 which is compact version of grand_slam_win[order(grand_slam_win)] ## Stan Wawrinka Andy Murray Novak Djokovic Rafael Nadal Roger Federer ## 5 9 12 15 18 There are of course many other useful functions that allow to deal with vectors which we will not mention in this section but can be found in a variety of references (see for example Wickham (2014)). 2.1.7 Creation sequences When uing R for statistical programming or even data analysis it is very common to create sequences of numbers. Here are three common ways used to create such sequences: from:to: This method is quite inituitive and very compact. For example: (x = 1:3) ## [1] 1 2 3 (y = 3:1) ## [1] 3 2 1 (w = -1:-4) ## [1] -1 -2 -3 -4 (z = 1.3:3) ## [1] 1.3 2.3 seq_len(n): This function provides a simple way to generate a sequence from 1 to an arbitrary number n. In general, 1:n and seq_len(n) are equivalent with the notable exeptions where n = 0 and n &lt; 0. The reason for these exeptions will become clear in Section 3.2.2.1. Let’s see a few examples: n = 3 1:n ## [1] 1 2 3 seq_len(n) ## [1] 1 2 3 n = 0 1:n ## [1] 1 0 seq_len(n) ## integer(0) seq(a, b, by/length.out = d): This function can be used to create more “complex” sequences. It can either be used to create a sequence from a to b by increments of d (using the option by) or of a total length of d (using the option length.out). A few examples: (x = seq(1, 2.8, by = 0.4)) ## [1] 1.0 1.4 1.8 2.2 2.6 (y = seq(1, 2.8, length.out = 6)) ## [1] 1.00 1.36 1.72 2.08 2.44 2.80 It could be interesting to use a function like rep() that allows to create vectors with repeated values or sequences, for example: rep(c(1,2), times = 3, each = 1) ## [1] 1 2 1 2 1 2 rep(c(1,2), times = 1, each = 3) ## [1] 1 1 1 2 2 2 where the option times allows to specify how many times the object needs to be repeated and each regulates how many times each element in the object is repeated. 2.1.8 Example: Apple Stock Price Suppose that one is interested in analysing the behavior of Apple’s stoch price over the last three months. The first thing that is need is today’s date which can be obtained as follows (today = Sys.Date()) ## [1] &quot;2017-07-29&quot; Once this is done, we can obtain the date which is exactly three monmths ago (three_months_ago = seq(today, length = 2, by = &quot;-3 months&quot;)[2]) ## [1] &quot;2017-04-29&quot; With this information, we can now download Apple’s stock price and represent these stocks through a candlestick chart which summarizes information on daily opening and closing prices as well as minimum and maximum prices. library(quantmod) getSymbols(&quot;AAPL&quot;, from = three_months_ago, to = today) ## [1] &quot;AAPL&quot; candleChart(AAPL, theme=&#39;white&#39;, type=&#39;candles&#39;) Once we have the prices, we can compute some returns which are defined as follows \\[\\begin{equation} r_t = \\frac{S_t - S_{t-1}}{S_{t-1}} \\end{equation}\\] where \\(r_t\\) are the returns at time t and \\(S_t\\) is the stock price. This is implemented in the function ClCl() within the quantmod package. For example, we can create a vector of returns as follows AAPL_returns = as.numeric(na.omit(ClCl(AAPL))) where na.omit is used to remove missing values in the stock prices vector since, if we have \\(n+1\\) stock prices, we will only have \\(n\\) returns and as.numeric is used to transform the computed returns into a numeric vector. We can now compute the mean and median of the returns over the considered period mean(AAPL_returns) ## [1] 0.0003870694 median(AAPL_returns) ## [1] 0.002557922 However, a statistic that is of particular interest to financial operators is the Excess Kurtosis which, for a random variable that we denote as \\(X\\), can be defined as \\[\\begin{equation} \\text{Kurt} = \\frac{{E}\\left[\\left(X - E[X]\\right)^4\\right]}{\\left({E}\\left[\\left(X - E[X]\\right)^2\\right]\\right)^2} - 3 \\end{equation}\\] The reason for defining this statistic as Excess Kurtosis lies in the fact that the standardized kurtosis is compared to that of a Gaussian distribution (whose kurtosis is equal to 3) which has exponentially decaying tails. Consequently, if the Excess Kurtosis is positive, this implies that the distribution has heavier tails than a Gaussian and therefore has higher probabilities of extreme events occurring. Given this statistic, it is useful to compute this on the observed data and for this purpose a common estimator of the excess Kurtosis is \\[\\begin{equation} k = \\frac{\\frac{1}{n} \\sum_{t = 1}^{n} \\left(r_t -\\bar{r}\\right)^4}{\\left(\\frac{1}{n} \\sum_{t = 1}^{n} \\left(r_t -\\bar{r}\\right)^2 \\right)^2} - 3 \\end{equation}\\] where \\(\\bar{k}\\) denotes the sample average of the returns, i.e. \\[\\begin{equation} \\bar{k} = \\frac{1}{n} \\sum_{i = 1}^n r_i \\end{equation}\\] mu = mean(AAPL_returns) (k = mean((AAPL_returns - mu)^4)/(mean((AAPL_returns - mu)^2))^2 - 3) ## [1] 2.004566 which is quite high tends to indicate the returns have a heavier tails than the normal distribution. 2.2 Matrix Matrices are another extremely common data structure in R. Compared to vectors, matrices have an additional dimension which, for example, allows to stock multiple equidimensional vectors within the same object. Below is an example of how to create a matrix in R: (mat = matrix(1:12, ncol = 4, nrow = 3)) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Notice that the first argument to the function is a vector (in this case a vector with increasing elements from 1 to 12) which is then transformed into a matrix with four columns (ncol = 4) and three rows (nrow = 3). By default, the vectors are transformed into matrices by placing the elements by column (i.e. starting from the top of the first column to the bottom and then passing to the following column until all columns are full). If you wish to fill the matrix by row, all you need to do is specify the argument byrow = T. Usually the length of the vector (i.e. number of elements in the vector) is the result of the multiplication between the number of columns and number of rows. What happens if the vector has fewer elements for the same matrix dimension? What happens if the vector has more elements? It is often the case however that we already have equidimensional vectors available and we wish to stock them into a matrix. In these cases, two useful functions are cbind() and rbind() where the first function stocks the vectors vertically side-by-side while the second stocks the vectors horizontally one below the other. An example of the former is given below: players = c(&quot;Andy Murray&quot;, &quot;Rafael Nadal&quot;, &quot;Stan Wawrinka&quot;, &quot;Novak Djokovic&quot;, &quot;Roger Federer&quot;) grand_slam_win = c(9, 15, 5, 12, 18) win_percentage = c(78.07, 82.48, 63.96, 82.77, 81.80) (mat = cbind(grand_slam_win, win_percentage)) ## grand_slam_win win_percentage ## [1,] 9 78.07 ## [2,] 15 82.48 ## [3,] 5 63.96 ## [4,] 12 82.77 ## [5,] 18 81.80 The result in this case is a \\(5 \\times 2\\) matrix (while with rbind() it would have been a \\(2 \\times 5\\) matrix). Once the matrix is defined, we can assign names to its rows and columns by using resepctively rownames and colnames. Of course, the number of names must correspond to the respective matrix dimensions as shown in the following example where each row corresponds to a specific player (thereby using the players vector) and each column corresponds to a specific statistic on the players. rownames(mat) &lt;- players colnames(mat) &lt;- c(&quot;GS win&quot;, &quot;Win rate&quot;) mat ## GS win Win rate ## Andy Murray 9 78.07 ## Rafael Nadal 15 82.48 ## Stan Wawrinka 5 63.96 ## Novak Djokovic 12 82.77 ## Roger Federer 18 81.80 2.2.1 Subsetting As for vectors, it is possible to subset the elements of a matrix. However, in the case of matrices we’re dealing with two-dimensional data structures and it is therefore necessary to specify the position of the elements of interest in both dimensions. For this purpose, as with vectors, we can use [ ] but, as opposed to vectors, we need to add , within the square brackets where the rows are specified before the comma and the columns after it. Below are a few examples: mat[c(&quot;Stan Wawrinka&quot;, &quot;Roger Federer&quot;), ] ## GS win Win rate ## Stan Wawrinka 5 63.96 ## Roger Federer 18 81.80 mat[c(1, 3), ] ## GS win Win rate ## Andy Murray 9 78.07 ## Stan Wawrinka 5 63.96 mat[, 2] ## Andy Murray Rafael Nadal Stan Wawrinka Novak Djokovic Roger Federer ## 78.07 82.48 63.96 82.77 81.80 mat[1:3, 1] ## Andy Murray Rafael Nadal Stan Wawrinka ## 9 15 5 It can be noticed that, when a space is left blank before or after the comma, this means that respectively all the rows or all the columns are considered. 2.2.2 Useful Functions to Work with Matrices As with vectors, there are some useful functions that can be used with matrices. A first example is the function dim() that allows to determine the dimension of a matrix. For example, consider the following \\(4 \\times 2\\) matrix \\[\\begin{equation*} \\mathbf{A} = \\left[ \\begin{matrix} 1 &amp; 5\\\\ 2 &amp; 6\\\\ 3 &amp; 7\\\\ 4 &amp; 8 \\end{matrix} \\right] \\end{equation*}\\] which can be created in R as follows: (A = matrix(1:8, 4, 2)) ## [,1] [,2] ## [1,] 1 5 ## [2,] 2 6 ## [3,] 3 7 ## [4,] 4 8 Therefore, we expect dim(A) to retrun the vector c(4, 2). Indeed, we have dim(A) ## [1] 4 2 Next, we consider the function t() allows transpose a matrix. For example, \\(\\mathbf{A}^T\\) is equal to: \\[\\begin{equation*} \\mathbf{A}^T = \\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 &amp; 4\\\\ 5 &amp; 6 &amp; 7 &amp; 8 \\end{matrix} \\right], \\end{equation*}\\] which is a \\(2 \\times 4\\) matrix. In R, we achieve this as follows (At &lt;- t(A)) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 dim(At) ## [1] 2 4 Aside from playing with matrix dimensions, matrix algebraic operations have specific commands. For example, the operator %*% is used in R to denote matrix multiplication while, as opposed to scalar objects, the regular product operator * performs the Hadamard product (or element by element product) when applied to matrices. For example, consider the following matrix product \\[\\begin{equation*} \\mathbf{B} = \\mathbf{A}^T \\mathbf{A} = \\left[ \\begin{matrix} 30 &amp; 70\\\\ 70 &amp; 174 \\end{matrix} \\right], \\end{equation*}\\] which can be done in R as follows: (B = At %*% A) ## [,1] [,2] ## [1,] 30 70 ## [2,] 70 174 Other common matrix operations include finding the determinant of a matrix and finding its inverse. These are often used, for example, when computing the likelihood function for a variable following a Gaussian distribution or when simulating time series or spatial data. The functions that perform these operations are det() and solve() that respectively find the determinant and the inverse of a matrix (which necessarily has to be square). The function det() can be used to compute the determinant of a (squared) matrix. In the case of a \\(2 \\times 2\\) matrix, there exists a simple solution for the determinant which is \\[\\begin{equation*} \\text{det} \\left( \\mathbf{D} \\right) = \\text{det} \\left( \\left[ \\begin{matrix} d_1 &amp; d_2\\\\ d_3 &amp; d_4 \\end{matrix} \\right] \\right) = d_1 d_4 - d_2 d_3. \\end{equation*}\\] Consider the matrix \\(\\mathbf{B}\\), we have \\[\\begin{equation*} \\text{det} \\left( \\mathbf{B}\\right) = 30 \\cdot 174 - 70^2 = 320. \\end{equation*}\\] In R, we can simply do det(B) ## [1] 320 The function solve() is also an important function when working with matrices as it allows to inverse a matrix. It is worth remembering that a square matrix that is not invertible (i.e. \\(\\mathbf{A}^{-1}\\) doesn’t exist) is called singular and the determinant offers a way to “check” if this is the case for a given matrix. Indeed, a square matrix is singular if and only if its determinant is 0. Therefore, in the case of \\(\\mathbf{B}\\), we should be able to compute its inverse. As for the determinant, there exists a formula to compute the inverse of \\(2 \\times 2\\) matrices, i.e. \\[\\begin{equation*} \\mathbf{D}^{-1} = \\left[ \\begin{matrix} d_1 &amp; d_2\\\\ d_3 &amp; d_4 \\end{matrix} \\right]^{-1} = \\frac{1}{\\text{det}\\left( \\mathbf{D} \\right)} \\left[ \\begin{matrix} \\phantom{-}d_4 &amp; -d_2\\\\ -d_3 &amp; \\phantom{-}d_1 \\end{matrix} \\right]. \\end{equation*}\\] Considering the matrix \\(\\mathbf{B}\\), we obtain \\[\\begin{equation*} \\mathbf{B}^{-1} = \\left[ \\begin{matrix} 30 &amp; 70\\\\ 70 &amp; 174 \\end{matrix} \\right]^{-1} = \\frac{1}{320}\\left[ \\begin{matrix} \\phantom{-}174 &amp; -70\\\\ -70 &amp; \\phantom{-}30 \\end{matrix} \\right] = \\end{equation*}\\] (B_inv = solve(B)) ## [,1] [,2] ## [1,] 0.54375 -0.21875 ## [2,] -0.21875 0.09375 Finally, we can verify that \\[\\begin{equation*} \\mathbf{G} = \\mathbf{B} \\mathbf{B}^{-1}, \\end{equation*}\\] should be equal to the identity matrix, (G = B %*% B_inv) ## [,1] [,2] ## [1,] 1 -8.881784e-16 ## [2,] 0 1.000000e+00 The result is of course extremely close but \\(\\mathbf{G}\\) is not exactly equal to the identity matrix due to rounding and other numerical errors. Another function of interest is the function diag() that can be used to extract the diagonal of a matrix. For example, we have \\[\\begin{equation*} \\text{diag} \\left( \\mathbf{B} \\right) = \\left[30 \\;\\; 174\\right], \\end{equation*}\\] which can be done in R as follows: diag(B) ## [1] 30 174 Therefore, the function diag() allows to easily compute the trace of matrix (i.e. the sum of the diagonal elements). For example, \\[\\begin{equation*} \\text{tr} \\left( \\mathbf{B} \\right) = 204, \\end{equation*}\\] or in R sum(diag(B)) ## [1] 204 Another use of the function diag() is to create diagonal matrices. Indeed, if the argument of this function is a vector, its behavior is the following: \\[\\begin{equation*} \\text{diag} \\left(\\left[a_1 \\;\\; a_2 \\;\\; \\cdots \\;\\; a_n\\right]\\right) = \\left[ \\begin{matrix} a_1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; a_2 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; a_n \\end{matrix} \\right]. \\end{equation*}\\] Therefore, this provides a simple way of creating an identity matrix by combining the functions diag() and rep() (discussed in the previous section) as follows: n = 4 (ident = diag(rep(1, n))) ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 1 0 0 ## [3,] 0 0 1 0 ## [4,] 0 0 0 1 2.2.3 Example: Summary Statistics with Matrix Notation A simple example of the operations we discussed in the previous section is given by many common statistics that can be reexpressed using matrix notation. As an example, we will consider three common statistics that are the sample mean, variance and covariance. Let us consider the following two samples of size \\(n\\) \\[\\begin{equation*} \\begin{aligned} \\mathbf{x} &amp;= \\left[x_1 \\;\\; x_2 \\; \\;\\cdots \\;\\; x_n\\right]^T\\\\ \\mathbf{y} &amp;= \\left[y_1 \\;\\;\\; y_2 \\; \\;\\;\\cdots \\;\\;\\; y_n\\right]^T. \\end{aligned} \\end{equation*}\\] The sample mean of \\(\\mathbf{x}\\) is \\[\\begin{equation*} \\bar{x} = \\frac{1}{n} \\sum_{i = 1}^{n} x_i, \\end{equation*}\\] and its sample variance is \\[\\begin{equation*} s_x^2 = \\frac{1}{n} \\sum_{i = 1}^n \\left(x_i - \\bar{x}\\right)^2. \\end{equation*}\\] The sample covariance between \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\) is \\[\\begin{equation*} s_{x,y} = \\frac{1}{n} \\sum_{i = 1}^n \\left(X_i - \\bar{x}\\right) \\left(Y_i - \\bar{y}\\right), \\end{equation*}\\] where \\(\\bar{y}\\) denotes the sample mean of \\(\\mathbf{y}\\). Consider the sample mean, this statistic can be expressed in matrix notation as follows \\[\\begin{equation*} \\bar{x} = \\frac{1}{n} \\sum_{i = 1}^{n} x_i = \\frac{1}{n} \\mathbf{x}^T \\mathbf{1}, \\end{equation*}\\] where \\(\\mathbf{1}\\) is a column vector of \\(n\\) ones. \\[\\begin{equation*} \\begin{aligned} s_x^2 &amp;= \\frac{1}{n} \\sum_{i = 1}^n \\left(x_i - \\bar{x}\\right)^2 = \\frac{1}{n} \\sum_{i = 1}^n x_i^2 - \\bar{x}^2 = \\frac{1}{n} \\mathbf{x}^T \\mathbf{x} - \\bar{x}^2\\\\ &amp;= \\frac{1}{n} \\mathbf{x}^T \\mathbf{x} - \\left(\\frac{1}{n} \\mathbf{x}^T \\mathbf{1}\\right)^2 = \\frac{1}{n} \\left(\\mathbf{x}^T \\mathbf{x} - \\frac{1}{n} \\mathbf{x}^T \\mathbf{1} \\mathbf{1}^T \\mathbf{x}\\right)\\\\ &amp;= \\frac{1}{n}\\mathbf{x}^T \\left( \\mathbf{I} - \\frac{1}{n} \\mathbf{1} \\mathbf{1}^T \\right) \\mathbf{x} = \\frac{1}{n}\\mathbf{x}^T \\mathbf{H} \\mathbf{x}, \\end{aligned} \\end{equation*}\\] where \\(\\mathbf{H} = \\mathbf{I} - \\frac{1}{n} \\mathbf{1} \\mathbf{1}^T\\). This matrix is often called the centering matrix. Similarly, for the sample covariance we obtain \\[\\begin{equation*} \\begin{aligned} s_{x,y} &amp;= \\frac{1}{n} \\sum_{i = 1}^n \\left(x_i - \\bar{x}\\right) \\left(y_i - \\bar{y}\\right) = \\frac{1}{n}\\mathbf{x}^T \\mathbf{H} \\mathbf{y}. \\end{aligned} \\end{equation*}\\] In the code below we verify the validity of these results by comparing the value of the three statistics based on the different formulas. # Sample size n = 100 # Simulate random numbers from a zero mean normal distribution with # variance equal to 4. x = rnorm(n, 0, sqrt(4)) # Simulate random numbers from normal distribution with mean 3 and # variance equal to 1. y = rnorm(n, 3, 1) # Note that x and y are independent. # Sample mean one = rep(1, n) (x_bar = 1/n*sum(x)) ## [1] -0.3777272 (x_bar_mat = 1/n*t(x)%*%one) ## [,1] ## [1,] -0.3777272 # Sample variance H = diag(rep(1, n)) - 1/n * one %*% t(one) (s_x = 1/n * sum((x - x_bar)^2)) ## [1] 4.661235 (s_x_mat = 1/n*t(x) %*% H %*% x) ## [,1] ## [1,] 4.661235 # Sample covariance y_bar = 1/n*sum(y) (s_xy = 1/n*sum((x - x_bar)*(y - y_bar))) ## [1] -0.1118769 (s_xy_mat = 1/n*t(x) %*% H %*% y) ## [,1] ## [1,] -0.1118769 2.2.4 Example: Least-squares If the matrix \\(\\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1}\\), the least-squares estimator for \\(\\boldsymbol{\\beta}\\) is given by: \\[\\begin{equation} \\hat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1} \\mathbf{X}^T \\mathbf{y} \\tag{2.1} \\end{equation}\\] In the comment box below, we derive Eq. (2.1). If you aren’t familiar with such calculation it might to read or something like this The least-square estimator \\(\\hat{\\boldsymbol{\\beta}}\\) can be defined as \\[\\begin{equation*} \\hat{\\boldsymbol{\\beta}} = \\operatorname{argmin}_{\\boldsymbol{\\beta}} \\; \\left( \\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta} \\right)^T \\left( \\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta} \\right) \\end{equation*}\\] The first step of this derivation is to rexpress the term \\(\\left( \\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta} \\right)^T \\left( \\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta} \\right)\\) as follows: \\[\\begin{equation*} \\left( \\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta} \\right)^T \\left( \\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta} \\right) = \\mathbf{y}^T\\mathbf{y} + \\boldsymbol{\\beta}^T \\mathbf{X}^T \\mathbf{X} \\boldsymbol{\\beta} - 2 \\boldsymbol{\\beta}^T \\mathbf{X}^T \\boldsymbol{y}. \\end{equation*}\\] In case you were suprizied by the term \\(2 \\boldsymbol{\\beta}^T \\mathbf{X}^T \\boldsymbol{y}\\) remeber that a scalar can always be transpose with changing its value and therefore we have that $ ^T ^T = ^T $. Now, out next step is the compute \\[\\begin{equation*} \\frac{\\partial}{\\partial \\, \\boldsymbol{\\beta}} \\; \\left( \\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta} \\right)^T \\left( \\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta} \\right). \\end{equation*}\\] To do this we should remeber the following results \\[\\begin{equation*} \\frac{\\partial}{\\partial \\, \\boldsymbol{\\beta}} \\; \\boldsymbol{\\beta}^T \\mathbf{X}^T \\boldsymbol{y} = \\boldsymbol{y}^T \\mathbf{X}, \\end{equation*}\\] and \\[\\begin{equation*} \\frac{\\partial}{\\partial \\, \\boldsymbol{\\beta}} \\; \\boldsymbol{\\beta}^T \\mathbf{X}^T \\mathbf{X} \\boldsymbol{\\beta} = 2 \\boldsymbol{\\beta}^T \\mathbf{X}^T \\mathbf{X}. \\end{equation*}\\] The proof of these two results can for example be found in Propositions 7 and 9 of Prof. Barnes’ notes. Using these two results we obtain \\[\\begin{equation*} \\frac{\\partial}{\\partial \\, \\boldsymbol{\\beta}} \\; \\left( \\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta} \\right)^T \\left( \\mathbf{y} - \\mathbf{X} \\boldsymbol{\\beta} \\right) = 2 \\boldsymbol{\\beta}^T \\mathbf{X}^T \\mathbf{X} - 2 \\boldsymbol{y}^T \\mathbf{X}. \\end{equation*}\\] By solving for the first order condition (and under some technical assumptions not discussed here) we can redefine \\(\\hat{\\boldsymbol{\\beta}}\\) through the follwing equation \\[\\begin{equation*} \\hat{\\boldsymbol{\\beta}}^T \\mathbf{X}^T \\mathbf{X} = \\boldsymbol{y}^T \\mathbf{X}, \\end{equation*}\\] which is equivalent to \\[\\begin{equation*} \\mathbf{X}^T \\mathbf{X} \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\boldsymbol{y}. \\end{equation*}\\] If \\(\\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1}\\) exist, \\(\\hat{\\boldsymbol{\\beta}}\\) is therefore given by \\[\\begin{equation*} \\hat{\\boldsymbol{\\beta}} = \\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1} \\mathbf{X}^T \\mathbf{y}, \\end{equation*}\\] which verifies Eq. (2.1). The variance of \\(\\hat{\\boldsymbol{\\beta}}\\) is given by \\[\\begin{equation} \\text{Var} \\left(\\hat{\\boldsymbol{\\beta}} \\right) = \\sigma^2 \\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1}, \\tag{2.2} \\end{equation}\\] the derivation of this results is explain in the comment box below. We let \\(\\mathbf{A} = \\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1} \\mathbf{X}^T\\). Then, we have \\[\\begin{equation*} \\begin{aligned} \\text{Var} \\left(\\hat{\\boldsymbol{\\beta}} \\right) &amp;= \\text{Var} \\left( \\mathbf{A} \\mathbf{y} \\right) = \\mathbf{A} \\text{Var} \\left( \\mathbf{y} \\right) \\mathbf{A}^T = \\sigma^2 \\mathbf{A} \\mathbf{A}^T \\\\ &amp; = \\sigma^2 \\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1} \\mathbf{X}^T \\mathbf{X} \\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1} = \\sigma^2 \\left(\\mathbf{X}^T \\mathbf{X}\\right)^{-1}, \\end{aligned} \\end{equation*}\\] which verifies Eq. (2.2). To understand the above derivation we might be usefull to remind and point out a few things: \\(\\text{Var} \\left( \\mathbf{A} \\mathbf{y} \\right) = \\mathbf{A} \\text{Var} \\left( \\mathbf{y} \\right) \\mathbf{A}^T\\) since \\(\\mathbf{A}\\) is not a random variable. \\(\\mathbf{A} \\text{Var} \\left( \\mathbf{y} \\right) \\mathbf{A}^T = \\sigma^2 \\mathbf{A} \\mathbf{A}^T\\) since\\(\\text{Var} \\left( \\mathbf{y} \\right) = \\sigma^2 \\mathbf{I}\\) and therefore we have \\(\\mathbf{A} \\text{Var} \\left( \\mathbf{y} \\right) \\mathbf{A}^T = \\sigma^2 \\mathbf{A} \\mathbf{I} \\mathbf{A}^T = \\sigma^2 \\mathbf{A} \\mathbf{A}^T\\). The result \\(\\mathbf{A} \\mathbf{A}^T = (\\mathbf{X}^T \\mathbf{X})^{-1}\\) is based on the fact that \\((\\mathbf{X}^T \\mathbf{X})^{-1}\\) is symmetric but this is not necessarily intuitive. Indeed, this follows from the fact that any square and invertible matrix \\(\\mathbf{B}\\) is such that the inverse and transpose operator commute, meaning that \\(( \\mathbf{B}^T )^{-1} = ( \\mathbf{B}^{-1} )^T\\). Therefore since the matrix \\(\\mathbf{X}^T \\mathbf{X}\\) is square and (by assumption) invertible we have \\([(\\mathbf{X}^T \\mathbf{X})^{-1}]^T = [(\\mathbf{X}^T \\mathbf{X})^{T}]^{-1} = ( \\mathbf{X}^T \\mathbf{X})^{-1}\\). In general, the residual variance is unknown and needs to estimate. A common and unbiased estimator of \\(\\sigma^2\\) is given by \\[\\begin{equation} \\hat{\\sigma}^2 = \\frac{1}{n - p} \\left( \\mathbf{y} - \\mathbf{X}\\hat{\\boldsymbol{\\beta}} \\right)^T \\left( \\mathbf{y} - \\mathbf{X} \\hat{\\boldsymbol{\\beta}}\\right) \\tag{2.3} \\end{equation}\\] DO YOU GUYS THINK WE SHOULD SHOW THE UNBIASEDNESS IN BOX HERE. THIS IS A LITTLE MORE ADVANCED AS WE NEED TO USE PROJECTION MATRICES AND THEIR PROPERTIES. LET ME KNOW. Let’s implement Eq. (2.1) to (2.3) and compare with the lm() implemented in base R. Before doing maybe we could use the dataset hubble. I think it is quite cool as it can be used to estimate the “age” of the universe and test wether the estimate of the age of the universe by Creation Scientists (based on a reading of the Bible) is reasonable. This is an example based on Simon Woods book. If we do this example, we should add something on confidence interval and I think he could the normal distribution (instead of t-distribution) to avoid going into details. Anyway the t-test relies on Normal assumption which is hard to verify. In the following chapter, we could use this example to show the various form of boostrap (parametric, non-parametric, semi-parametric). Let me know what you think. 2.3 Array 2.4 List 2.5 Dataframe 2.5.1 Example: Making Maps birth_place = c(&quot;Glasgow, Scotland&quot;, &quot;Manacor, Spain&quot;, &quot;Lausanne, Switzerland&quot;, &quot;Belgrade, Serbia&quot;, &quot;Basel, Switzerland&quot;) library(ggmap) glasgow_coord = geocode(&quot;Glasgow, Scotland&quot;) glasgow_coord ## lon lat ## 1 -4.251806 55.86424 birth_coord = geocode(birth_place) birth_coord ## lon lat ## 1 -4.251806 55.86424 ## 2 3.209532 39.56972 ## 3 6.632273 46.51965 ## 4 20.448922 44.78657 ## 5 7.588576 47.55960 class(birth_coord) ## [1] &quot;data.frame&quot; birth_coord$Players = players birth_coord$GS = grand_slam_win birth_coord ## lon lat Players GS ## 1 -4.251806 55.86424 Andy Murray 9 ## 2 3.209532 39.56972 Rafael Nadal 15 ## 3 6.632273 46.51965 Stan Wawrinka 5 ## 4 20.448922 44.78657 Novak Djokovic 12 ## 5 7.588576 47.55960 Roger Federer 18 Let’s represent this information graphically. We haven’t seen how to make graph yet so don’t worry to much about the details of how this graph is made library(mapproj) map &lt;- get_map(location = &#39;Switzerland&#39;, zoom = 4) ggmap(map) + geom_point(data = birth_coord, aes(lon, lat, col = Players, size = GS)) + scale_size(name=&quot;Grand Slam Wins&quot;) + xlab(&quot;Longitude&quot;) + ylab(&quot;Latitude&quot;) 2.6 Data frames A data frame is the most common way of storing data in R, it has a 2D structure and shares properties of both the matrix and the list. We can create a data frame using data.frame() ### Creation players = c(&quot;Andy Murray&quot;, &quot;Rafael Nadal&quot;, &quot;Stan Wawrinka&quot;, &quot;Novak Djokovic&quot;, &quot;Roger Federer&quot;) grand_slam_win = c(9, 15, 5, 12, 18) date_of_birth = c(&quot;15 May 1987&quot;, &quot;3 June 1986&quot;, &quot;28 March 1985&quot;, &quot;22 May 1981&quot;, &quot;8 August 1981&quot;) country = c(&quot;Great Britain&quot;, &quot;Spain&quot;, &quot;Switzerland&quot;, &quot;Serbia&quot;, &quot;Switzerland&quot;) ATP_ranking = c(1, 2, 3, 4, 5) prize_money = c(60449649, 85920132, 30577981, 109447408, 104445185) tennis = data.frame(date_of_birth, grand_slam_win, country, ATP_ranking, prize_money) dimnames(tennis)[[1]] = players tennis ## date_of_birth grand_slam_win country ATP_ranking ## Andy Murray 15 May 1987 9 Great Britain 1 ## Rafael Nadal 3 June 1986 15 Spain 2 ## Stan Wawrinka 28 March 1985 5 Switzerland 3 ## Novak Djokovic 22 May 1981 12 Serbia 4 ## Roger Federer 8 August 1981 18 Switzerland 5 ## prize_money ## Andy Murray 60449649 ## Rafael Nadal 85920132 ## Stan Wawrinka 30577981 ## Novak Djokovic 109447408 ## Roger Federer 104445185 We can check if we have achived our gooal by using: is.data.frame(tennis) ## [1] TRUE 2.6.1 Combination Different data frames can also be combined. Let say we want to add some ifomrmation to our initial table e.g. the player’s height and if he is right-handed or letf-handed. We can do so by using cbind() and rbind(): height &lt;- c(1.90, 1.85, 1.83, 1.88, 1.85) hand &lt;- c(&quot;R&quot;,&quot;L&quot;,&quot;R&quot;,&quot;R&quot;,&quot;R&quot;) (tennis = cbind(tennis, data.frame(height, hand))) ## date_of_birth grand_slam_win country ATP_ranking ## Andy Murray 15 May 1987 9 Great Britain 1 ## Rafael Nadal 3 June 1986 15 Spain 2 ## Stan Wawrinka 28 March 1985 5 Switzerland 3 ## Novak Djokovic 22 May 1981 12 Serbia 4 ## Roger Federer 8 August 1981 18 Switzerland 5 ## prize_money height hand ## Andy Murray 60449649 1.90 R ## Rafael Nadal 85920132 1.85 L ## Stan Wawrinka 30577981 1.83 R ## Novak Djokovic 109447408 1.88 R ## Roger Federer 104445185 1.85 R 2.6.2 Subsetting Like for vectors, it is also possible to subset the values that we have stored in our data frames. Since data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices. # Let say we want only want to know the country and date of # birth of the players # There are two ways to select columns from a data frame # Like a list: tennis[c(&quot;country&quot;, &quot;date_of_birth&quot;)] ## country date_of_birth ## Andy Murray Great Britain 15 May 1987 ## Rafael Nadal Spain 3 June 1986 ## Stan Wawrinka Switzerland 28 March 1985 ## Novak Djokovic Serbia 22 May 1981 ## Roger Federer Switzerland 8 August 1981 # Like a matrix tennis[, c(&quot;country&quot;, &quot;date_of_birth&quot;)] ## country date_of_birth ## Andy Murray Great Britain 15 May 1987 ## Rafael Nadal Spain 3 June 1986 ## Stan Wawrinka Switzerland 28 March 1985 ## Novak Djokovic Serbia 22 May 1981 ## Roger Federer Switzerland 8 August 1981 # To acces a single element, let say the date of birth, # you can also use: tennis$date_of_birth ## [1] 15 May 1987 3 June 1986 28 March 1985 22 May 1981 8 August 1981 ## 5 Levels: 15 May 1987 22 May 1981 28 March 1985 ... 8 August 1981 2.6.3 Application: Non-parametric bootstrap Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour) student_work &lt;- c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4) We can compute the mean time spent mean(student_work) ## [1] 0.825 ADD SOMETHING ON T TEST t.test(student_work)$conf.int ## [1] -0.03495865 1.68495865 ## attr(,&quot;conf.level&quot;) ## [1] 0.95 We can see that our confidence interval includes a negative values which clearly isn’t meaningful. Solution: (non-parametric) bootstrap which works as follows….. ADD SOMETHING Here is a simple function to implement this approach: # Number of boostrap replications B = 500 # Compute the length of vector n = length(student_work) # Confidence level alpha = 0.05 # Initialisation of boot_mean = rep(NA, B) for (i in 1:B){ student_work_star = student_work[sample(1:n, replace = TRUE)] boot_mean[i] = mean(student_work_star) } quantile(boot_mean, c(alpha/2, 1 - alpha/2)) ## 2.5% 97.5% ## 0.275000 1.763125 #hist(boot_mean, probability = TRUE) References "],
["control.html", "Chapter 3 Logical Operators and Control Stuctures 3.1 Logical Operators 3.2 Control Structures 3.3 Applications:", " Chapter 3 Logical Operators and Control Stuctures 3.1 Logical Operators 3.2 Control Structures 3.2.1 Selection Controls Basically if, if/else, if/elseif/else and switch 3.2.2 Iteration Controls 3.2.2.1 for 3.3 Applications: 3.3.1 Non-parametric Bootstrap Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour) student_work = c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4) We can compute the mean time spent mean(student_work) ## [1] 0.825 ADD SOMETHING ON T TEST t.test(student_work)$conf.int ## [1] -0.03495865 1.68495865 ## attr(,&quot;conf.level&quot;) ## [1] 0.95 We can see that our confidence interval includes a negative values which clearly isn’t meaningful. Solution: (non-parametric) bootstrap which works as follows….. ADD SOMETHING Here is a simple function to implement this approach: # Number of boostrap replications B = 500 # Compute the length of vector n = length(student_work) # Confidence level alpha = 0.05 # Initialisation of boot_mean = rep(NA, B) for (i in 1:B){ student_work_star = student_work[sample(1:n, replace = TRUE)] boot_mean[i] = mean(student_work_star) } quantile(boot_mean, c(alpha/2, 1 - alpha/2)) ## 2.5% 97.5% ## 0.250 1.575 #hist(boot_mean, probability = TRUE) "],
["functions.html", "Chapter 4 Functions 4.1 Function arguments 4.2 Function body 4.3 Function environment", " Chapter 4 Functions This chapter aims at highlighting the main advantages, characteristics, arguments and structure of functions in R. As you already know, a function is a collection of logically connected commands and operations that allow the user to input some arguments and obtain a desired output (based on the given arguments) without having to rewrite the mentioned code each time that specific output is needed. Indeed, a common task in statistical research consists in running some simulation studies which give support (or not) to the use of a certain method of inference. In this case, it’s not efficient to rewrite the code each time it is needed within a simulation study because it would lead to lengthy code and increased risk of miss-coding. Considering this, in the previous chapter we discussed the non-parametric bootstrap which is a technique used to perform statistical inference in different cases (e.g. small sample sizes, uncertainty on the distribution of the underlying variable, etc.). However, there exist many other types of bootstrap techniques, including the parametric bootstrap which assumes a parametric model for the data (e.g. a Gaussian distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\) that represent the parameters). For this bootstrap technique, we assume that we know the underlying model generating the data and therefore estimate its parameters. Once this is done, we use the estimated parameters as if they were the true parameters and use them to simulate from the assumed model. In this manner we generate a parametric bootstrap sample on which we can compute the statistic we are intersted in (e.g. the sample mean), thereby obtaining a distribution for this statistic by simulating many other samples. What are the advantages of these different inferential methods? Which approach appears to be preferable to the others and under what circumstances? We can run some specific simulation studies to get an idea of the answers to these questions but, to do so, we will need to create functions the implement these methods. The next sections will present the main features of functions in R by studying their main components. R functions have three main components to them: body: the code lines containing the commands and operations which deliver the desired output; arguments: the inputs the user gives to the function which will determine the value or type of output of a function; environment: every R function is built within an enviroment of reference from which to source possible input values and/or other functions necessary for it to work. We will briefly go over these components by building a function implementing the non-parametric bootstrap to find a confidence interval for the sample mean which we saw in the previous chapter: nonpar_boot &lt;- function(x, B = 500, alpha = 0.05) { boot_mean &lt;- rep(NA, B) n &lt;- length(x) for (i in 1:B) { sample_star = x[sample(1:n, replace = TRUE)] boot_mean[i] = mean(sample_star) } return(quantile(boot_mean, c(alpha/2, 1 - alpha/2))) } 4.1 Function arguments As you can see, the function’s name is “nonpar_boot( )” and it has three arguments to it: “x” which represents the original sample on which we would like to perform the bootstrap procedure; “B” which represents the number of bootstrap samples we wish to generate; “alpha” which determines the size of the confidence interval we wish to compute The function therefore has three arguments to it and these can be extracted by using the function “formals( )” formals(nonpar_boot) ## $x ## ## ## $B ## [1] 500 ## ## $alpha ## [1] 0.05 A feature which can be underlined at this stage is that, as can be seen for the above mentioned function, it is possible to provide default values for some, all or none of the function arguments. In this case, default values have been given for the arguments B and alpha, consequently the user does not need to specify the value of these arguments unless they wish to specify different values compared to the default values given. R functions are quite flexible when specifying the arguments. These can in fact be specified by exact name, prefix matching or position (and are given priority in this order). For example, one could specify the arguments for the above non-parametric bootstrap function as follows “nonpar_boot(B = 200, sim, a = 0.1)” where the object “sim” is the sample which in the function is named “x”. For a more in-depth overview of this feature refer to Wickham (2014). 4.2 Function body 4.3 Function environment References "],
["build-a-package.html", "Chapter 5 Build a package", " Chapter 5 Build a package Expalin how to build a package, I would add style guide and something on pkgdown "],
["case-study-monte-carlo-integration.html", "Chapter 6 Case Study: Monte-Carlo Integration 6.1 Introduction 6.2 Properties 6.3 Implementation 6.4 Example: Normal Distribution 6.5 Example: Nonelementary integral 6.6 To delete…", " Chapter 6 Case Study: Monte-Carlo Integration 6.1 Introduction Monte Carlo integration is a powerful technique for numerical integration. It is particularly useful to evaluate integrals of “high-dimension”. A detailed (and formal) discussion of this method is clearly beyond the scope of this class and we shall restrict our attention to most basic form(s) of Monte Carlo Integration and briefly discuss the rational behind this method. Originally, such Monte Carlo methods were known under various names among which statistical sampling was probably the most commonly used. In fact, the name Monte Carlo was popularized by several physics researchers, including Stanislaw Ulam, Enrico Fermi and John von Neumann. The name is believed to be a reference to a famous casino in Monaco where Stanislaw Ulam’s uncle would borrow money to gamble. Enrico Fermi was one of the first to this technique which he employed to study the properties newly-discovered neutron in the 1930s. Later, these methods played for example a central role in many of the simulations required for the Manhattan project. Suppose we are interested in computing the following integral: \\[I = \\int_a^b f(x) dx.\\] Of course, this integral can be approximated by a Riemann sum, \\[I \\approx \\Delta x \\sum_{i = 1}^n f(a + (i-1) \\Delta x),\\] where \\(\\Delta x = \\frac{b - a}{n}\\;\\) and the idea behind this approximation is that as the number of partions \\(n\\) increases the Riemann sum will become closer and closer to \\(I\\). Also (and under some technical conditions), we have that \\[I = \\lim_{n \\to \\infty} \\Delta x \\sum_{i = 1}^n f(a + (i-1) \\Delta x).\\] In fact, the rational of a Monte Carlo Integral is quite close to the Riemann sum since, in its most basic form, we approximate \\(I\\) by averaging samples of the function \\(f(x)\\) at uniform random point within the interval \\([a, b]\\). Therefore, the Monte Carlo estimator of \\(I\\) is given by \\[\\begin{equation} \\hat{I} = \\frac{b - a}{B} \\sum_{i = 1}^B f(X_i), \\tag{6.1} \\end{equation}\\] where \\(X_i = a + U_i (b - a)\\) and \\(U_i \\sim \\mathcal{U}(0,1)\\). In fact, (6.1) is quite intuitive as \\(\\frac{1}{B} \\sum_{i = 1}^B f(X_i)\\) represents an estimation of the average value of \\(f(x)\\) in the interval \\([a, b]\\) and thus \\(\\hat{I}\\) is simply the average value time the length of the interval, i.e. \\((b-a)\\). 6.2 Properties A more formal argument on the validity of this approach can be found in analyzing the statistical properties of the estimator \\(\\hat{I}\\). In order to do so, we start by considering its expected value \\[ \\mathbb{E}\\left[ \\hat{I} \\right] = \\frac{b - a}{B} \\sum_{i = 1}^B \\mathbb{E}\\left[ f(X_i) \\right] = \\frac{b - a}{B} \\sum_{i = 1}^B \\int f(x) g(x) dx, \\] where \\(g(x)\\) denotes the pdf of \\(X_i\\). Since \\(X_i \\sim \\mathcal{U}(a, b)\\) it follows that \\[ g(x) = \\left\\{ \\begin{array}{ll} \\frac{1}{b - a} &amp; \\mbox{if } x \\in [a, b] \\\\ 0 &amp; \\mbox{if } x \\not\\in [a, b] \\end{array} \\right. \\] Therefore, we have \\[ \\mathbb{E}\\left[ \\hat{I} \\right] = \\frac{b - a}{B} \\sum_{i = 1}^B \\int_a^b \\frac{f(x)}{b-a} dx = \\int_a^b f(x) dx = I, \\] Since \\(X_i\\) are iid, the same can be said about \\(f(X_i)\\) and therefore by the Strong Law of Large Numbers we have that \\(\\hat{I}\\) converge almost surely to \\(I\\), which means that \\[ \\mathbb{P}\\left(\\lim_{B \\to \\infty} \\hat{I} = I \\right) = 1. \\] This result implies that as the number of simulations \\(B\\) goes to infinity we can guarantee that the solution will be exact. If you are unfamiliar or don’t remeber well the Strong Law of Large Numbers we provide a reminder in the comment box below. IS THAT USEFUL? Unfortunately, this result does give us any information on how quickly this estimate converges to “sufficiently accurate” solution for the problem at hand. This can be done by studying the variance of \\(\\hat{I}\\) and its rate of convergence. Indeed, we have \\[ \\begin{aligned} \\operatorname{var} \\left( \\hat{I} \\right) &amp;= \\left(\\frac{b - a}{B}\\right)^2 \\sum_{i = 1}^B \\left\\{\\mathbb{E}\\left[f^2(X_i)\\right] - \\mathbb{E}^2\\left[f(X_i)\\right]\\right\\}\\\\ &amp;= \\frac{1}{B^2} \\sum_{i = 1}^B \\left\\{(b-a) \\int_a^b f^2(x) dx - \\left(\\int_a^b f(x) dx \\right)^2 \\right\\}\\\\ &amp;= \\frac{(b-a) I_2 - I^2}{B} \\end{aligned} \\] where \\(I_2 = \\int_a^b f^2(x) dx\\). A simple estimator of this quantity is given by \\[ \\hat{I}_2 = \\frac{b - a}{B} \\sum_{i = 1}^B f^2(X_i), \\] and therefore using \\(\\hat{I}\\) we obtain: \\[ \\widehat{\\operatorname{var}} \\left(\\hat{I} \\right) = \\frac{(b-a) \\hat{I}_2 - \\hat{I}^2}{B} = \\frac{b - a}{B^2} \\sum_{i = 1}^B\\left[ (b - a )f^2(X_i) - f(X_i)\\right] \\] Thus, it is easy to see that the rate of convergence of \\(\\widehat{\\operatorname{var}} \\left(\\hat{I} \\right)\\) is \\(B^{-1}\\) and we may write \\({\\operatorname{var}} \\left(\\hat{I} \\right) = \\mathcal{O}(B)\\). This implies that if we wish to reduce the error (or standard deviation) by half we need to quadruple \\(B\\). Such phenomon is very common in many research such as Statistics is often called the curse of dimensionality. 6.3 Implementation The function mc_int(), which is available in the support package, implements the above method. This functions has four inputs: x_range: A vector containing the integration domain, i.e. \\(a\\) and \\(b\\), fun: A string containing the function you wish to integrate where \\(x\\) is used to indicate the variable of integration, B: A numeric value to denote the number of Monte-Carlo replications, seed: A numeric to control the seed of the random number generator. For example, if you want to estimate \\[ \\int_1^3 \\frac{\\exp\\left(\\sin(x)\\right)}{x} dx, \\] using \\(10^4\\) Monte-Carlo replications, you can use the following command: mc_int(x_range = c(1,3), fun = &quot;exp(sin(x))/x&quot;, B = 10^5) ## $I ## [1] 2.558104 ## ## $var ## [1] 1.401222e-05 At this point, it is probably a good idea to try to programm this yourself and to compare your results (and code!) with the function mc_int(). This should be rather easy to implement but one thing that may be a little delicate is how to pass as an input the function you wish to integrate. A possible way of doing this is to use a string for this purpose so that, for example, if we have to integrate the function \\(\\sin(x)\\) you could simply write fun = sin(x) when calling your function. This implies that we should be able to “transform” a string into a function that we can evaluate, which is something that we can achieve by combining the functions eval and parse. An example is provided below: my_fun = &quot;x^2&quot; x = 0:3 eval(parse(text = my_fun)) ## [1] 0 1 4 9 If you having trouble to understand what these functions are doing have a look to their help files with write ?eval and ?parse. 6.4 Example: Normal Distribution Suppose that \\(X \\sim \\mathcal{N}(4, 1.25^2)\\) and that we are interested in computing the following probability \\(\\mathbb{P}\\left(1 &lt; X &lt; 4.5 \\right)\\). The probability density of the normal distribution for a random variable with mean \\(\\mu\\) and variance \\(\\sigma^2\\) is given by: \\[ f(x) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left(- \\frac{\\left(x - \\mu\\right)^2}{2 \\sigma^2}\\right). \\] Therefore, the probability we are interested in can written as the following integral \\[ \\mathbb{P}\\left(1 &lt; X &lt; 4.5 \\right) = \\int_1^{4.5} \\frac{1}{\\sqrt{3.125 \\pi}} \\exp \\left(- \\frac{\\left(x - 4\\right)^2}{3.125}\\right). \\] Analytically, this is not an easy problem and of course there are many ways to solve it. However, we could try to use Monte-Carlo integral to solve it. For example: my_fun = &quot;1/sqrt(3.125*pi)*exp(-((x - 4)^2)/3.125)&quot; (prob = mc_int(x_range = c(1, 4.5), fun = my_fun, B = 10^7)) ## $I ## [1] 0.6471691 ## ## $var ## [1] 1.449985e-08 Based on this result, we can write \\(\\mathbb{P}\\left(1 &lt; X &lt; 4.5 \\right) \\approx 64.72 \\%\\) with a standard error of about 0.01%. We can compare our results with what we would obtain with the function pnorm which provide a nearly exact result: pnorm(4.5, 4, 1.25) - pnorm(1, 4, 1.25) ## [1] 0.6472242 This shows that our estimation is within one standard error of a near perfect result. 6.5 Example: Nonelementary integral Layman’s terms, a nonelementary integral of a given (elementary) function is an integral that is cannot be expressed as an elementary function. The French mathematicien Joseph Liouville was the first to proof the existing of such nonelementary integral. An well-known example of such integrals are the Fresnel integrals, which have been used for a very wide range of applications going from the computation of electromagnetic field intensity to roller roster design. These integrals are defined as: \\[S(y) = \\int_0^t \\sin\\left(x^2\\right) dx \\;\\;\\;\\;\\;\\; \\text{and} \\;\\;\\;\\;\\;\\; C(y) = \\int_0^y \\cos \\left( x^2 \\right) dx.\\] In this example, we will only consider \\(S(y)\\). In general it is believed that the most convenient way of evaluating these functions to arbitrary precision is to use power series representation that converges for all \\(y\\): \\[ S(y) = \\sum_{i = 1}^\\infty \\, \\left(-1\\right)^n \\, \\frac{y^{4i + 1}}{\\left(2i + 1\\right) \\, !\\left(4i + 3\\right)}. \\] In this example, we will study the estimation of \\(S(\\pi)\\) as well as the precision of this estimation. B = 4^(4:13) results = matrix(NA, length(B), 2) for (i in 1:length(B)){ mc_res = mc_int(c(0, 2), &quot;sin(x^2)&quot;, B = B[i], seed = i+12) results[i, ] = c(mc_res$I, sqrt(mc_res$var)) } trans_blue = hcl(h = seq(15, 375, length = 3), l = 65, c = 100, alpha = 0.15)[2] plot(NA, xlim = range(B), ylim = range(cbind(results[, 1] + results[,2], results[, 1] -results[,2])), log = &quot;x&quot;, ylab = &quot;Estimated Integral&quot;, xlab = &quot;Number of Simulations B&quot;, xaxt = &#39;n&#39;) grid() axis(1, at = B, labels = parse(text = paste(&quot;4^&quot;, 4:13, sep = &quot;&quot;))) polygon(c(B, rev(B)), c(results[, 1] + results[, 2], rev(results[, 1] - results[, 2])), border = NA, col = trans_blue) lines(B, results[, 1], type = &quot;b&quot;, col = &quot;blue4&quot;, pch = 16) abline(h = 0.8048208, col = &quot;red4&quot;, lty = 2) legend(&quot;topright&quot;, c(&quot;Estimated value&quot;, &quot;Standard error interval&quot;, &quot;Good approximation (MatLab)&quot;), bty = &quot;n&quot;, pch = c(16, 15, NA), lwd = c(1, NA, 1), lty = c(1, NA, 2), pt.cex = c(1, 2, NA), col = c(&quot;blue4&quot;, trans_blue, &quot;red4&quot;)) 6.6 To delete… n_step = 10^3 x = seq(from = -0.35, to = 3.35, length.out = n_step) y = x^2 set.seed(6) Ui = runif(4, 0 ,3) par(mfrow = c(1, 4)) for (i in 1:4){ plot(NA, xlim = range(x), ylim = range(y), xlab = &quot;x&quot;, ylab = &quot;f(x)&quot;) grid() trans_col = hcl(h = seq(15, 375, length = 5), l = 65, c = 100, alpha = 0.15)[1:5] lines(x, y, col = &quot;blue4&quot;) points(Ui[i], Ui[i]^2, pch = 16, col = &quot;yellow2&quot;) polygon(c(0, Ui[i], Ui[i], 0), c(0, 0, Ui[i]^2, Ui[i]^2), border = NA, col = trans_col[i]) } Example \\[ I = \\int_0^3 x^2 dx = \\frac{1}{3} \\left[x^3\\right]_0^3 = 9 \\] \\[ \\widehat{\\operatorname{var}} \\left(\\hat{I} \\right) = \\mathcal{O}(B^{-1}). \\] The Monte-Carlo approach generalized in the following way. We suppose again that we wish to solve \\[\\int_a^b f(x) dx,\\] and that \\(X_i \\sim G\\) where the pdf of \\(X_i\\) is such that \\[ \\max_{\\mathbb{R} \\setminus [a, b]} \\; g(x) = 0 . \\] \\[ \\tilde{I} = \\frac{1}{B}\\sum_{i = 1}^B \\frac{f(X_i)}{g(X_i)} \\] Of course, in the case \\(X_i \\mathcal{U}(a, b)\\), then \\(\\hat{I}\\) and \\(\\hat{I}\\) are equivalent. \\[ \\mathbb{E} \\left[ \\tilde{I} \\right] = \\] To understand the very basic idea of Monte Carlo integration we shall start with a simple example. Suppose we wish to compute: \\[ I_1 = \\int_{-1}^2 3x^2 dx. \\] It is easy to verify that \\(\\max_{\\Omega} \\; f(x) = 12\\) and \\(\\min_{\\Omega} \\; f(x) = 0\\) where \\(\\Omega = (-1, 2)\\) and therefore we have that \\[I_1 \\leq I_2 = \\int_{-1}^2 \\int_{0}^{12} dy dx = 36.\\] The following code and image illustrates the situation: n_step = 10^3 x = seq(from = -1.35, to = 2.35, length.out = n_step) x_in_omega = x[x &gt;= -1 &amp; x &lt;= 2] y = 3*x^2 col_I1 = hcl(h = seq(15, 375, length = 3), l = 65, c = 100, alpha = 0.2)[2] plot(NA, xlim = range(x), ylim = range(y), xlab = &quot;x&quot;, ylab = &quot;f(x)&quot;) grid() polygon(c(-1, 2, 2, -1), c(0, 0, 12, 12), border = &quot;red3&quot;, lty = 2, lwd = 2) polygon(c(x_in_omega, rev(x_in_omega)), c(rep(0, length(x_in_omega)), rev(y[x &gt;= -1 &amp; x &lt;= 2])), border = &quot;NA&quot;, col = col_I1) lines(x, y, col = &quot;blue4&quot;) legend(&quot;topleft&quot;, c(expression(I[1]), expression(I[2]), &quot;f(x)&quot;), bty = &quot;n&quot;, pch = c(NA, 15, NA), lwd = c(2, NA, 1), lty = c(2, NA, 1), pt.cex = c(2, 2, NA), col = c(&quot;red3&quot;, col_I1, &quot;blue4&quot;)) Suppose that we generate (uniformly) a large number points, with coordinates (\\(U_1\\), \\(U_2\\)) inside the red region. We assume that \\(U_1 \\sim \\mathcal{U}(-1, 2)\\) and \\(U_2 \\sim \\mathcal{U}(0, 12)\\). The function below also t #&#39; Generate random points with bivariate uniform distribution #&#39; #&#39; @param x_range A vector of dimension 2 used to denote the parameter #&#39; of the uniform distribution on the x-axis. #&#39; @param y_range A vector of dimension 2 used to denote the parameter #&#39; of the uniform distribution on the y-axis. #&#39; @param B A positive number used to denote the number of simulation. #&#39; @param seed A number used to control the seed of the random number #&#39; generated by this function. #&#39; @return A B x 2 matrix containing the simulated points. #&#39; @examples #&#39; gen_points(x_range = c(0, 1), y_range = c(0, 2), B = 10) #&#39; gen_points(x_range = c(-10, 1), y_range = c(0, 0.1), B = 5) gen_points = function(x_range, y_range, B, seed = 1291){ # A few checks # Check x_range if (length(x_range) != 2 || x_range[1] &gt;= x_range[2]){ error(&quot;x_range is uncorrely specified&quot;) } # Check y_range if (length(y_range) != 2 || y_range[1] &gt;= y_range[2]){ error(&quot;y_range is uncorrely specified&quot;) } # Check B if (B &lt; 1){ error(&quot;B is uncorrely specified&quot;) } # Set seed set.seed(seed) # Let&#39;s draw some uniforms mat_out = matrix(runif(2*B), B, 2) mat_out[, 1] = mat_out[, 1]*diff(x_range) + x_range[1] mat_out[, 2] = mat_out[, 2]*diff(y_range) + y_range[1] mat_out } B = 500 mc_points = gen_points(x_range = c(-1, 2), y_range = c(0, 12), B = B) n_step = 10^3 x = seq(from = -1.35, to = 2.35, length.out = n_step) x_in_omega = x[x &gt;= -1 &amp; x &lt;= 2] y = 3*x^2 col_I1 = hcl(h = seq(15, 375, length = 3), l = 65, c = 100, alpha = 0.2)[2] plot(NA, xlim = range(x), ylim = range(y), xlab = &quot;x&quot;, ylab = &quot;f(x)&quot;) grid() polygon(c(-1, 2, 2, -1), c(0, 0, 12, 12), border = &quot;red3&quot;, lty = 2, lwd = 2) polygon(c(x_in_omega, rev(x_in_omega)), c(rep(0, length(x_in_omega)), rev(y[x &gt;= -1 &amp; x &lt;= 2])), border = &quot;NA&quot;, col = col_I1) lines(x, y, col = &quot;blue4&quot;) points(mc_points, pch = 19, cex = 0.5) legend(&quot;topleft&quot;, c(expression(I[1]), expression(I[2]), &quot;f(x)&quot;), bty = &quot;n&quot;, pch = c(NA, 15, NA), lwd = c(2, NA, 1), lty = c(2, NA, 1), pt.cex = c(2, 2, NA), col = c(&quot;red3&quot;, col_I1, &quot;blue4&quot;)) "],
["chap-graphs.html", "Chapter 7 Graphics", " Chapter 7 Graphics In this chapter we discuss graphics with R. In this chapter, we will as an example the function sin(x) in the range \\(0, 2\\pi)\\). nb_points &lt;- 60 x &lt;- seq(from = 0, to = 4*pi, length.out = nb_points) y &lt;- sin(x) plot(x, y) In general, we found that the following approach is quite usefull, Step 1: Construct graph “frame”, i.e. basically an empty graph with the right title, labels, axis and so on. Often, this can be achieve with plot(). It is also useful to grid. Here is an example: plot(NA, xlim = range(x), ylim = range(y), main = &quot;my title&quot;, xlab = &quot;my xlab&quot;, ylab = &quot;my ylab&quot;, col.main = &quot;red&quot;, col.lab = &quot;darkgreen&quot;, col.axis = &quot;darkblue&quot;, cex.main = 2, cex.lab = 1, cex.axis = 0.5) grid() full link "],
["r-markdown.html", "Chapter 8 R Markdown 8.1 YAML Metadata 8.2 Text 8.3 Code Chunks 8.4 Render Output", " Chapter 8 R Markdown RMarkdown is a framework that provides a literate programming format for data science. It can be used to save and execute R code within RStudio, and also is a simple formatting syntax for authoring HTML, PDF, ODT, RTF, and MS Word documents. An RMarkdown is a plain text file that contains three different aspects: YAML metadata Text Code Chunks 8.1 YAML Metadata YAML stands for YAML Ain’t Markup Language, and is used to specify document configurations and properties such as name, date, output format, etc. The (optional) YAML header surrounded by —s. You can also include additional formatting options, such as a table of contents, or even custom CSS which can utilized to further enhance presentation. For the purpose of the class, the default options should be sufficient. 8.2 Text In addition, due to its literate nature, text will be an essential part in explaining your analysis. With RMarkdown, we can specify custom text formatting, such as with emphasis such as italics, bold, or even a code style. Headings are preceded with a #, breaks create a new paragraph. There are many more elements to creating a useful report using RMarkdown, and we encourage you to use the Rmarkdown Cheatsheet as a reference. 8.3 Code Chunks This is where you enter your code. You can quickly insert chunks like these into your file with the keyboard shortcut Ctrl + Alt + I (OS X: Cmd + Option + I) the Add Chunk command in the editor toolbar by typing the chunk delimiters {r} and. Like third code chunk above, we can also set up chunk options. Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. This is a useful way to embed figures. More options can be referred from the Rmarkdown Cheatsheet. 8.4 Render Output After you are done, run rmarkdown::render() or click the knit HTML button at the top of the RStudio scripts pane to save the output in your working directory. Click on the links below for more information on RMarkdown: RMarkdown Example File RStudio RMarkdown tutorial R-blogger’s RMarkdown tutorial "],
["github.html", "Chapter 9 GitHub 9.1 Version Control 9.2 Git and GitHub 9.3 Git Setup 9.4 Configuration 9.5 GitHub Setup 9.6 Student Developer Pack", " Chapter 9 GitHub You may have experienced a moment like this once in your life: After plenty hours of hard work, you only find yourself saving the same file over and over - even losing track of what changes you made. Version control is a software that keeps track of your changes for you. You know which saves you made where, and can even go back in time to revert to those changes. (Awesome!) 9.1 Version Control Version control is a system that records changes to a file or a set of files over time, so that you can save changes over time. It allows you to: keep the entire history of a file revert to a specific version of the file collaborate on the same platform with other people make changes without modifying the main file 9.2 Git and GitHub Among version control platform, Git is a powerful tool that is commonly used. GitHub is a commercial website that uses Git and stores local files into a “album” called a repository. For the purposes of this course, we will be using this platform. In addition, your GitHub profile will also serve as your data science resume that contain future projects that you save and commit so that employers know what you’re made of. 9.3 Git Setup To install Git, go to the website and choose the platform you are using. (eg. Windows/Mac/Linux/Solaris) 9.4 Configuration The first thing you should do when you install Git is to set your user name and email address. This is important because every Git commit uses this information, and it’s immutably baked into the commits you start creating: $ git config --global user.name &quot;John Doe&quot; $ git config --global user.email johndoe@example.com Again, you need to do this only once if you pass the –global option, because then Git will always use that information for anything you do on that system. If you want to override this with a different name or email address for specific projects, you can run the command without the –global option when you’re in that project. Many of the GUI tools will help you do this when you first run them. 9.5 GitHub Setup To begin, head over to GitHub and sign up with your PSU email address. (don’t worry, you can change your Username/Email anytime after this course!) On Step 2: Choose your plan choose the default plan (Unlimited public repositories for free.) and click Continue. You can either submit your information or skip Step 3: Tailor your experience. Once you have set up your profile, make sure you verify your email address. Also, send me your GitHub user ID (eg. jjl170) to jjl170@psu.edu. 9.6 Student Developer Pack Once you have set up your profile, go to this link and follow the steps below to set up a student developer pack discount request to GitHub. You will need this to make your own private repositories for free. I will add a tutorial to how to submit your homework and assignments using GitHub. "]
]
