## Array {#array}

Simply, vectors are one-dimensional and matrices are two-dimensional objects, and these homogenous objects are also known as **arrays**. We can extend the array into more than two dimensions by specifying the `dim` parameter within the `array` function. Arrays are rarer than matrices and vectors, but worth being aware of.

Below we initialize a three dimensional array, from 2 to 13. 
```{r}
three_dim <- array(data = 2:13, dim = c(2, 3, 2))
three_dim
```

As you can see, two 2x3 matrices were created containing numbers from 2 to 13. The `, , *` syntax describes which specific dimension the matrix is contained in. 
Like what we experimented with matrices, we can extract and manipulate information. 

```{r}
length(three_dim) # length is 12 
dim(three_dim) # dimensions are 2x3x2
is.array(three_dim) # yes it is an array!
```

Note that when changing the dimension names, we need to save it as a `list`. We will talk more about lists in the coming section. 

```{r}
dimnames(three_dim) <- list(c("apple", "banana"), c("one", "two", "three"), c("Walmart", "Costco")) # feel free to make 
three_dim
```


## List

A list is one of the commonly used heterogeneous data structures, which depicts a generic vector containing other object types. For example, we can have a numeric vector as one element, a matrix, and a character vector as another element. Here we can create a list that contains all these different element types. 

```{r}
num_vec <- c(160, 188, 140)
char_vec <- c("Height", "Weight", "Length")
my_mat <- matrix(0, nrow = 5, ncol = 5)

# List Initialization without Names 
# list(num_vec, char_vec, my_mat)

# List Initialization with Custom Names 
list(Number <- num_vec, Character = char_vec, Empty_Mat = my_mat)
```

Let's store this list in a variable. 

```{r}
my_list <- list(Number = num_vec, Character = char_vec, Empty_Mat = my_mat)
```

We can subset lists like we did previously. 

```{r}
# Extract the first and third element 
my_list[c(1, 3)]

# Compare these two subsets  
my_list[1]
my_list[[1]]
```

Do you see what the difference is? One generally uses `[[` to select any single element, whereas `[` returns a list of the selected elements. Using one bracket retains the class information, while using two brackets simplifies the list into a numeric vector. 

We can further subset the list. 

```{r}
# First element of the $Number list 
my_list[[1]][1]

# Why didn't this work? 
my_list[1][1]
```


## Dataframe

*Needs some rewording* 
 
A data frame is used for storing data tables. A data frame is the most common way of storing data in R, it has a 2D structure and shares properties of both the matrix and the list. The table contains lists of equal-length vectors, and most datasets will have a data frame format. 

We can create a data frame using data.frame() 

```{r}
### Creation

players <- c("Andy Murray", "Rafael Nadal", "Stan Wawrinka", 
             "Novak Djokovic", "Roger Federer")

grand_slam_win <- c(9, 15, 5, 12, 18)

date_of_birth <- c("15 May 1987", "3 June 1986", "28 March 1985", 
                  "22 May 1981", "8 August 1981")

country = c("Great Britain", "Spain", "Switzerland", 
            "Serbia", "Switzerland")
ATP_ranking <- c(1, 2, 3, 4, 5)

prize_money <- c(60449649, 85920132, 30577981, 109447408, 104445185)

tennis <- data.frame(date_of_birth, grand_slam_win, country, 
                    ATP_ranking, prize_money)

dimnames(tennis)[[1]] <- players
tennis

```

We can check if we have achived our goal by using:

```{r}
is.data.frame(tennis)
```

### Combination

Different data frames can also be combined. Let say we want to add some ifomrmation to our initial table e.g. the player's height and if he is right-handed or letf-handed. 

We can do so by using `cbind()` and `rbind()`:

```{r}
height <- c(1.90, 1.85, 1.83, 1.88, 1.85)
hand <- c("R","L","R","R","R")

(tennis <- cbind(tennis, data.frame(height, hand)))
```

### Subsetting

Like for vectors, it is also possible to subset the values that we have stored in our data frames. Since data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.

```{r}
# Let say we want only want to know the country and date of 
# birth of the players

# There are two ways to select columns from a data frame
# Like a list:
tennis[c("country", "date_of_birth")]

# Like a matrix
tennis[, c("country", "date_of_birth")]

# To acces a single element, let say the date of birth, 
# you can also use:
tennis$date_of_birth
```

### Application: Non-parametric bootstrap

Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour)

```{r}
student_work <- c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4)
```

We can compute the mean time spent

```{r}
mean(student_work)
```

*ADD SOMETHING ON T TEST*

```{r}
t.test(student_work)$conf.int
```

We can see that our confidence interval includes a negative values which clearly isn't meaningful. Solution: (non-parametric) bootstrap which works as follows..... ADD SOMETHING

Here is a simple function to implement this approach:

```{r}
# Number of boostrap replications
B <- 500

# Compute the length of vector
n <- length(student_work)

# Confidence level
alpha <- 0.05

# Initialisation of 
boot_mean <- rep(NA, B)

for (i in 1:B){
  student_work_star <- student_work[sample(1:n, replace = TRUE)]
  boot_mean[i] <- mean(student_work_star)
}

quantile(boot_mean, c(alpha/2, 1 - alpha/2))
#hist(boot_mean, probability = TRUE)

```
