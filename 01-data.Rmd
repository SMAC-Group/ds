# Data Structures {#data}

Brievely explain the types of data strucutres in R. Basically there are five

- Vector: homogenous, 1D
- Matrix: homogenous, 2D
- Array: homogenous, nD
- List: Heterogeneous, 1D
- Data Frame: Heterogeneous, 2D

To illustrate the things we will in this chapter....

as of 07/15/17 (Men single)

 Name              Date of Birth       Country            ATP Ranking     Prize Money    Win Percentage   Grand Slam Wins
----------------  ---------------  -------------------  ---------------  -------------- ---------------- ------------------
Andy Murray        15 May 1987     Great Britain            1             60,449,649         78.07               9
Rafael Nadal       3 June 1986       Spain                   2            85,920,132         82.48               15
Stan Wawrinka      28 March 1985     Switzerland             3            30,577,981         63.96              5
Novak Djokovic    22 May 1987          Serbia                4            109,447,408        82.77              12
Roger Federer      8 August 1981      Switzerland            5            104,445,185        81.80              18



## Vectors 

A vector has three properties:

```{block2, note-text, type='rmdimportant'}
- **Type**, which corresponds the "kind" of objects in contains. It is possible to use the function `typeof()` to evaluate the type of objects in a vector.
- **Length**, i.e. the number of elements in a vector. This information can be obtained using the function `length()`.
- **Attributes**, some additional metadata attached to a vector. The functions `attr()` and `attributes()` can be used to store and retrive attributes (more details can be found in Section \@ref(vectattr))
```

For example, consider the number of grand slam won by the players 

```{r}
exp_res = c(1, 2, 3, 5, 1)
```

To display the values stored in `exp_res` we could simply do:

```{r}
exp_res
```


Alteratively, we could have create and display the value by using `()` around the defiition, for example:

```{r}
(exp_res = c(1, 2, 3, 5, 1))
```

We can evaluate the kind or type of elements that are stored in a vector using the function `typeof()`. For example, for the vector we just created we obtain:

```{r}
typeof(exp_res)
```

This is a little suprzing as all the elements in `exp_res` are integers it would seem natural to expect this as an output of the function `typeof()`. This is R considers by default any number as a "double", expet when spefiying `L` after an integer. For example,  

```{r}
typeof(1)
typeof(1L)
```

Therefore, we could express `exp_res` as follows:

```{r}
(exp_res_int = c(1L, 2L, 3L, 5L, 1L))
typeof(exp_res_int)
```

Naturally, the difference is the two in general relatively but we can see that `exp_res_int` takes less "space" to two. For example, we have

```{r}
object.size(exp_res)
object.size(exp_res_int)
```


### Subsetting

Naturally, it is possible to "subset" the values of in our vectror in many ways. Essentially, there are four main ways of subsetting a vector. Here we'll only discuss the first three:

- **Positive Index**: We can *access* or *subset* the $i$-th element of a vector by simply using `exp_res[i]` where $i$ is a positive number between 1 and length of the vector.

```{r}
# Accesing the first element
exp_res[1]

# Accesing the third and first value
exp_res[c(3, 1)]

# Duplicated indices yield duplicated values
exp_res[c(1, 1, 2, 2, 3, 4)]
```

- **Negative Index**: We *remove* elements in a vector using negative indices:

```{r}
# Removing the second obervation
exp_res[-2]

# Removing the first and fourth obserations
exp_res[c(-1, -4)]
```

- **Logical Indices**: Another usefull approach is based on *logical* operators:

```{r}
# Access the first and fourth observations
exp_res[c(TRUE, FALSE, FALSE, TRUE, FALSE)]
```

**ADD REMARK BOX**

Here we could add some remarks on weird cases, for example `exp_res[c(1.2, 3.4)]` (which rounds things up) or `exp_res[c(-1, 2)]` (which doesn't work as "mixed" indices are not permitted).

### Attributes {#vectattr}

Our experiment was conducted under specific conditions, say a date and a place which should be store are attributes. Indeed, objects can have arbitrary additional attributes, used to store metadata about the considered object. For example:

```{r}
attr(exp_res, "date") = "07-21-2017"
attr(exp_res, "location") = "Montreux, Switzerland"
```

To display the vector with its attributes

```{r}
exp_res
```

To only display the attributes
```{r}
attributes(exp_res)
```

It is also possible to extract a specific attribute

```{r}
attr(exp_res, "date")
```


### Dataframes


LG 

A data frame is the most common way of storing data in R, it has a 2D structure and shares properties of both the matrix and the list. 

We can create a data frame using data.frame() 

```{r}
student_work = c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4)
```

### Application: Non-parametric bootstrap

Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour)

```{r}
student_work = c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4)
```

We can compute the mean time spent

```{r}
mean(student_work)
```

*ADD SOMETHING ON T TEST*

```{r}
t.test(student_work)$conf.int
```

We can see that our confidence interval includes a negative values which clearly isn't meaningful. Solution: (non-parametric) bootstrap which works as follows..... ADD SOMETHING

Here is a simple function to implement this approach:

```{r}
# Number of boostrap replications
B = 500

# Compute the length of vector
n = length(student_work)

# Confidence level
alpha = 0.05

# Initialisation of 
boot_mean = rep(NA, B)

for (i in 1:B){
  student_work_star = student_work[sample(1:n, replace = TRUE)]
  boot_mean[i] = mean(student_work_star)
}

quantile(boot_mean, c(alpha/2, 1 - alpha/2))
#hist(boot_mean, probability = TRUE)

```
