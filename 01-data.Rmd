# Data Structures {#data}

Brievely explain the types of data strucutres in R. Basically there are five

- Vector: homogenous, 1D
- Matrix: homogenous, 2D
- Array: homogenous, nD
- List: Heterogeneous, 1D
- Data Frame: Heterogeneous, 2D

To illustrate the things we will in this chapter....

as of 07/15/17 (Men single)

 Name              Date of Birth         Born                Country            ATP Ranking     Prize Money    Win Percentage   Grand Slam Wins
----------------  ---------------  ---------------------- -------------------  ---------------  -------------- ---------------- ------------------
Andy Murray        15 May 1987     Glasgow, Scotland       Great Britain            1             60,449,649         78.07               9
Rafael Nadal       3 June 1986     Manacor, Spain           Spain                   2            85,920,132         82.48               15
Stan Wawrinka      28 March 1985   Lausanne, Switzerland    Switzerland             3            30,577,981         63.96              5
Novak Djokovic    22 May 1987       Belgrade, Serbia          Serbia                4            109,447,408        82.77              12
Roger Federer      8 August 1981    Basel, Switzerland      Switzerland            5            104,445,185        81.80              18



## Vectors 

A vector has three properties:

```{block2, note-text, type='rmdimportant'}
- **Type**, which corresponds the "kind" of objects in contains. It is possible to use the function `typeof()` to evaluate the type of objects in a vector.
- **Length**, i.e. the number of elements in a vector. This information can be obtained using the function `length()`.
- **Attributes**, some additional metadata attached to a vector. The functions `attr()` and `attributes()` can be used to store and retrive attributes (more details can be found in Section \@ref(vectattr))
```

For example, consider the number of grand slam won by the five players we are considering: 

```{r}
grand_slam_win = c(9, 15, 5, 12, 18)
```

To display the values stores in `grand_slam_win` we could simply do:


```{r}
grand_slam_win
```

Alteratively, we could have create and display the value by using `()` around the defiition, for example:

```{r}
(grand_slam_win = c(9, 15, 5, 12, 18))
```

It is also possible to define vector with characters, for example we could define a vector with the player names as follows:

```{r}
(players = c("Andy Murray", "Rafael Nadal", "Stan Wawrinka", 
             "Novak Djokovic", "Roger Federer"))
```

### Type 

We can evaluate the kind or type of elements that are stored in a vector using the function `typeof()`. For example, for the vectors we just created we obtain:

```{r}
typeof(grand_slam_win)
typeof(players)
```

This is a little suprzing as all the elements in `grand_slam_win` are integers it would seem natural to expect this as an output of the function `typeof()`. This is R considers by default any number as a "double", expet when spefiying `L` after an integer. For example,  

```{r}
typeof(1)
typeof(1L)
```

Therefore, we could express `exp_res` as follows:

```{r}
(grand_slam_win_int = c(1L, 2L, 3L, 5L, 1L))
typeof(grand_slam_win_int)
```

Naturally, the difference between the two in general relatively unimportant but we can see that `exp_res_int` takes less "space" to two. For example, we have

```{r}
object.size(grand_slam_win)
object.size(grand_slam_win_int)
```


### Subsetting

Naturally, it is possible to "subset" the values of in our vectror in many ways. Essentially, there are four main ways of subsetting a vector. Here we'll only discuss the first three:

- **Positive Index**: We can *access* or *subset* the $i$-th element of a vector by simply using `exp_res[i]` where $i$ is a positive number between 1 and length of the vector.

```{r}
# Accesing the first element
grand_slam_win[1]

# Accesing the third and first value
grand_slam_win[c(3, 1)]

# Duplicated indices yield duplicated values
grand_slam_win[c(1, 1, 2, 2, 3, 4)]
```

- **Negative Index**: We *remove* elements in a vector using negative indices:

```{r}
# Removing the second obervation
grand_slam_win[-2]

# Removing the first and fourth obserations
grand_slam_win[c(-1, -4)]
```

- **Logical Indices**: Another usefull approach is based on *logical* operators:

```{r}
# Access the first and fourth observations
grand_slam_win[c(TRUE, FALSE, FALSE, TRUE, FALSE)]
```

```{block2, type='rmdnote'}
Here we could add some remarks on weird cases, for example `exp_res[c(1.2, 3.4)]` (which rounds things up) or `exp_res[c(-1, 2)]` (which doesn't work as "mixed" indices are not permitted).
```



### Attributes {#vectattr}

Our experiment was conducted under specific conditions, say a date and a place which should be store are attributes. Indeed, objects can have arbitrary additional attributes, used to store metadata about the considered object. For example:

```{r}
attr(grand_slam_win, "date") = "07-15-2017"
attr(grand_slam_win, "type") = "Men, Single"
```

To display the vector with its attributes

```{r}
grand_slam_win
```

To only display the attributes
```{r}
attributes(grand_slam_win)
```

It is also possible to extract a specific attribute

```{r}
attr(grand_slam_win, "date")
```


### Useful functions with vectors

`length()` `sum()` `mean()` `sort()` and `order()`


### Example: Apple Stock Price 

```{r}
(today = Sys.Date())
```

```{r}
(three_months_ago = seq(today, length = 2, by = "-3 months")[2])
```

```{r, message = FALSE, fig.height = 5, fig.width = 6, fig.align = "center", warning = FALSE}
library(quantmod)
getSymbols("AAPL", from = three_months_ago, to = today)
candleChart(AAPL, theme='white', type='candles')
```

Let's compute returns...

\begin{equation}
  r_t = \frac{S_t - S_{t-1}}{S_{t-1}}
\end{equation}

where $r_t$ are the return, $S_t$ the stock price. This is implemented in the function `ClCl()` of the package `quantmod`. For example, we can create a vector of returns as follows 


```{r}
AAPL_returns = as.numeric(na.omit(ClCl(AAPL)))
```

`na.omit` to remove missing value as if we have $n+1$ stock prices we only $n$ returns
`as.numeric` to transform into a vector. We can now compute mean and median return over the period

```{r}
mean(AAPL_returns)
median(AAPL_returns)
```

Excess Kurtosis can be defined for a random variable $X$ as

\begin{equation}
  \text{Kurt} = \frac{{E}\left[\left(X - E[X]\right)^4\right]}{\left({E}\left[\left(X - E[X]\right)^2\right]\right)^2} - 3
\end{equation}

The reason excess is .... A common estimator of the excess Kurtosis is

\begin{equation}
  k = \frac{\frac{1}{n} \sum_{t = 1}^{n} \left(r_t -\bar{r}\right)^4}{\left(\frac{1}{n} \sum_{t = 1}^{n} \left(r_t -\bar{r}\right)^2 \right)^2} - 3
\end{equation}

where $\bar{k}$ denotes the sample average of the returns, i.e.

\begin{equation}
  \bar{k} = \frac{1}{n} \sum_{i = 1}^n r_i
\end{equation}

```{r}
mu = mean(AAPL_returns)
(k = mean((AAPL_returns - mu)^4)/(mean((AAPL_returns - mu)^2))^2 - 3)
```
 
which is quite high tends to indicate the returns have a heavier tails than the normal distribution.
 
### Example: Making Maps


```{r}
birth_place = c("Glasgow, Scotland", "Manacor, Spain", "Lausanne, Switzerland",
                "Belgrade, Serbia", "Basel, Switzerland")
```

```{r, message = FALSE}
library(ggmap)
glasgow_coord = geocode("Glasgow, Scotland")
```

```{r}
glasgow_coord
```

```{r, message = FALSE, cache = TRUE}
birth_coord = geocode(birth_place)
```

```{r}
birth_coord
```

```{r}
class(birth_coord)
```

```{r}
birth_coord$Players = players
birth_coord$GS = grand_slam_win
```

```{r}
birth_coord
```

Let's represent this information graphically. We haven't seen how to make graph yet so don't worry to much about the details of how this graph is made

```{r, message = FALSE, fig.align = "center", fig.height = 5, fig.width = 7.5, cache = TRUE}
library(mapproj)
map <- get_map(location = 'Switzerland', zoom = 4)
ggmap(map) + geom_point(data = birth_coord, 
             aes(lon, lat, col = Players, size = GS)) + 
             scale_size(name="Grand Slam Wins") + 
             xlab("Longitude") + ylab("Latitude")
```


## Data frames


LG 

A data frame is the most common way of storing data in R, it has a 2D structure and shares properties of both the matrix and the list. 

We can create a data frame using data.frame() 

```{r}
### Creation

players = c("Andy Murray", "Rafael Nadal", "Stan Wawrinka", 
             "Novak Djokovic", "Roger Federer")

grand_slam_win = c(9, 15, 5, 12, 18)

date_of_birth = c("15 May 1987", "3 June 1986", "28 March 1985", 
                  "22 May 1981", "8 August 1981")

country = c("Great Britain", "Spain", "Switzerland", 
            "Serbia", "Switzerland")
ATP_ranking = c(1, 2, 3, 4, 5)

prize_money = c(60449649, 85920132, 30577981, 109447408, 104445185)

tennis = data.frame(date_of_birth, grand_slam_win, country, 
                    ATP_ranking, prize_money)

dimnames(tennis)[[1]] = players
tennis

```

We can check if we have achived our gooal by using:

```{r}
is.data.frame(tennis)
```
### Combination

Different data frames can also be combined. Let say we want to add some ifomrmation to our initial table e.g. the player's height and if he is right-handed or letf-handed. 

We can do so by using `cbind()` and `rbind()`:

```{r}
height = c(1.90, 1.85, 1.83, 1.88, 1.85)
hand = (R','L','R','R','R','R')
```

### Subsetting

Like for vectors, it is also possible to subset the values that we have stored in our data frames. Since data frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.

```{r}
# Let say we want only want to know the country and date of birth of the players

# There are two ways to select columns from a data frame
# Like a list:

tennis[c("country", "date_of_birth")]

# Like a matrix
df[, c("country", "date_of_birth")]

# To acces a single element, let say the date of birth, you can also use:
tennis$date_of_birth
```

### Application: Non-parametric bootstrap

Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour)

```{r}
student_work = c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4)
```

We can compute the mean time spent

```{r}
mean(student_work)
```

*ADD SOMETHING ON T TEST*

```{r}
t.test(student_work)$conf.int
```

We can see that our confidence interval includes a negative values which clearly isn't meaningful. Solution: (non-parametric) bootstrap which works as follows..... ADD SOMETHING

Here is a simple function to implement this approach:

```{r}
# Number of boostrap replications
B = 500

# Compute the length of vector
n = length(student_work)

# Confidence level
alpha = 0.05

# Initialisation of 
boot_mean = rep(NA, B)

for (i in 1:B){
  student_work_star = student_work[sample(1:n, replace = TRUE)]
  boot_mean[i] = mean(student_work_star)
}

quantile(boot_mean, c(alpha/2, 1 - alpha/2))
#hist(boot_mean, probability = TRUE)

```
