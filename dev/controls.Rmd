# Logical Operators and Control Stuctures {#control}

## Logical Operators


## Control Structures



### Selection Controls

Basically if, if/else, if/elseif/else and switch

#### If/else

```{r, eval = FALSE}
if (conditon){
  do something (if conditon is TRUE)
}else{
  do seomthing else (if condition is false)
}
```
### Iteration Controls

#### for {#forloop}

(apply methods)

## Applications: 



### Non-parametric Bootstrap

Suppose we ask 10 students how much time they work at home for their calculus class, we obtain the following results (in hour)

```{r}
student_work = c(0, 0, 0, 0.25, 0.25, 0.75, 0.75, 1, 1.25, 4)
```

We can compute the mean time spent

```{r}
mean(student_work)
```

*ADD SOMETHING ON T TEST*

```{r}
t.test(student_work)$conf.int
```

We can see that our confidence interval includes a negative values which clearly isn't meaningful. Solution: (non-parametric) bootstrap which works as follows..... ADD SOMETHING

Here is a simple function to implement this approach:


```{r, eval = FALSE, highlight=FALSE}
step 1 do this
step 2 do that
```
```{r}
# Number of boostrap replications
B = 500

# Compute the length of vector
n = length(student_work)

# Confidence level
alpha = 0.05

# Initialisation of 
boot_mean = rep(NA, B)

for (i in 1:B){
  student_work_star = student_work[sample(1:n, replace = TRUE)]
  boot_mean[i] = mean(student_work_star)
}

quantile(boot_mean, c(alpha/2, 1 - alpha/2))
#hist(boot_mean, probability = TRUE)

```

```{r}
n = 10^(2:6)
m = 50
res = matrix(NA, m, length(n))

for (j in 1:length(n)){
  for (i in 1:m){
    set.seed(i)
    x = rnorm(n[j])
    res[i,j] = mean(x)
  }
}

min_range = apply(res, 2, min)
mean_range = apply(res, 2, mean)
max_range = apply(res, 2, max)

plot(mean_range, type = "l", ylim = range(cbind(min_range, max_range)))
lines(min_range)
lines(max_range)
```