<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An Introduction to Statistical Programming Methods with R</title>
  <meta name="description" content="This book is under construction and serves as a reference for students or other interested readers who intend to learn the basics of statistical programming using the R language. The book will provide the reader with notions of data management, manipulation and analysis as well as of reproducible research, result-sharing and version control.">
  <meta name="generator" content="bookdown 0.4.1 and GitBook 2.6.7">

  <meta property="og:title" content="An Introduction to Statistical Programming Methods with R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This book is under construction and serves as a reference for students or other interested readers who intend to learn the basics of statistical programming using the R language. The book will provide the reader with notions of data management, manipulation and analysis as well as of reproducible research, result-sharing and version control." />
  <meta name="github-repo" content="smac-group/ds" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An Introduction to Statistical Programming Methods with R" />
  
  <meta name="twitter:description" content="This book is under construction and serves as a reference for students or other interested readers who intend to learn the basics of statistical programming using the R language. The book will provide the reader with notions of data management, manipulation and analysis as well as of reproducible research, result-sharing and version control." />
  

<meta name="author" content="Matthew Beckman, Stéphane Guerrier, Justin Lee &amp; Roberto Molinari">


<meta name="date" content="2017-11-02">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="control.html">
<link rel="next" href="placeholder.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Statistical Programming Methods</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="part"><span><b>I Foundation</b></span></li>
<li class="chapter" data-level="2" data-path="rmarkdown.html"><a href="rmarkdown.html"><i class="fa fa-check"></i><b>2</b> RMarkdown</a></li>
<li class="chapter" data-level="3" data-path="github.html"><a href="github.html"><i class="fa fa-check"></i><b>3</b> GitHub</a></li>
<li class="part"><span><b>II Introduction to R</b></span></li>
<li class="chapter" data-level="4" data-path="data.html"><a href="data.html"><i class="fa fa-check"></i><b>4</b> Data Structures</a></li>
<li class="chapter" data-level="5" data-path="control.html"><a href="control.html"><i class="fa fa-check"></i><b>5</b> Control Structures</a></li>
<li class="chapter" data-level="6" data-path="functions.html"><a href="functions.html"><i class="fa fa-check"></i><b>6</b> Functions</a><ul>
<li class="chapter" data-level="6.1" data-path="functions.html"><a href="functions.html#r-functions"><i class="fa fa-check"></i><b>6.1</b> R functions</a></li>
<li class="chapter" data-level="6.2" data-path="functions.html"><a href="functions.html#creating-functions-in-r"><i class="fa fa-check"></i><b>6.2</b> Creating functions in R</a><ul>
<li class="chapter" data-level="6.2.1" data-path="functions.html"><a href="functions.html#function-arguments"><i class="fa fa-check"></i><b>6.2.1</b> Function arguments</a></li>
<li class="chapter" data-level="6.2.2" data-path="functions.html"><a href="functions.html#function-body"><i class="fa fa-check"></i><b>6.2.2</b> Function body</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="functions.html"><a href="functions.html#function-environment"><i class="fa fa-check"></i><b>6.3</b> Function environment</a></li>
<li class="chapter" data-level="6.4" data-path="functions.html"><a href="functions.html#example-continued-least-squares-function"><i class="fa fa-check"></i><b>6.4</b> Example (continued): Least-squares function</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="placeholder.html"><a href="placeholder.html"><i class="fa fa-check"></i><b>7</b> Placeholder</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">An Introduction to Statistical Programming Methods with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="functions" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Functions</h1>
<p>This chapter aims at highlighting the main advantages, characteristics, arguments and structure of functions in R. As you might already know, a function is a collection of logically connected commands and operations that allow the user to input some arguments and obtain a desired output (based on the given arguments) without having to rewrite the mentioned code each time that specific output is needed. Indeed, a common task in statistical research for example consists in running some simulation studies which give support (or not) to the use of a certain method of inference. In this case, it’s not efficient to rewrite the code each time it is needed within a simulation study because it would lead to lengthy code and increased risk of miss-coding.</p>
<p>In the following paragraphs, we will describe an example for which we will build a function that allows to respond to the related research question. Following from the previous chapter where we discussed matrix algebra in R, at the end of this chapter we will therefore implement a function that allows us to perform least-squares regression and inference using these notions of matrix algebra. Indeed, it may be interesting to understand the behavior of this estimator in different simulation settings and it would not be practical to rewrite the series of commands to obtain the least-squares estimator in each setting. For this reason, a function that implements this estimator would be more appropriate and, in fact, this function already exists in the base R functions and is called <code>lm()</code>. However, we will learn how to build our own least-squares regression function and compare its results with those of <code>lm()</code> to check if they’re the same. To do so, we will consider a dataset in which linear regression is used to study the age of the universe.</p>
<p><strong>Example: The Hubble Constant</strong></p>
<p>The example dataset we will study is taken from <span class="citation">Wood (<a href="#ref-wood2017generalized">2017</a>)</span> which discusses data collected from the Hubble Space Telescope key project containing information on the velocity and relative distance of 24 galaxies. This information has been used to compute the “Hubble constant” which is a fixed parameter that links velocity and distance of celestial bodies through which it is possible to compute the age of the universe based on the “Big Bang” theory. The link is given by this simple linear relationship</p>
<span class="math display">\[\begin{equation*}
  y = \beta x ,
\end{equation*}\]</span>
<p>where <span class="math inline">\(y\)</span> represents the velocity while <span class="math inline">\(x\)</span> is the distance between galaxies. Once the Hubble constant is known, its inverse (i.e. <span class="math inline">\(\beta^{-1}\)</span>) gives the age of the universe based on the big bang theory.</p>
<p>Therefore we will use the abovementioned dataset to estimate Hubble’s constant to then get an estimate of the age of the universe. This dataset can be found in the <code>gamair</code> package under the name <code>hubble</code> and when plotting the two variables of interest in a scatterplot there appears to be a positive linear relationship between the two variables.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load gamair library and retrieve Hubble dataset</span>
<span class="kw">library</span>(gamair)
<span class="kw">data</span>(hubble)

<span class="co"># Plot data</span>
<span class="kw">plot</span>(<span class="dt">y =</span> hubble$y, <span class="dt">x =</span> hubble$x, <span class="dt">col=</span><span class="st">&quot;darkblue&quot;</span>, <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">main=</span><span class="st">&quot;Distance vs. Velocity&quot;</span>, 
     <span class="dt">ylab =</span> <span class="st">&quot;Velocity (in km/s)&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;Distance (in Megaparsecs)&quot;</span>)
<span class="kw">grid</span>()</code></pre></div>
<p><img src="ds_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<p>By the end of this chapter we will therefore be able to build a function to obtain an estimate of <span class="math inline">\(\beta\)</span> and, consequently, an estimate of the age of the universe based on the big bang theory (as well as a means of testing whether a Creationist hypothesis on the age of the universe is reasonable based on the latter theory).</p>
<div id="r-functions" class="section level2">
<h2><span class="header-section-number">6.1</span> R functions</h2>
<p>In order to build our own functions, the next sections will present the main features of functions in R by studying their main components. The following annotated example gives a brief overview of a simple function that draws a random number issued from the “spin” of an American roulette:<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<center>
<img src="images/function.png" alt="Function Structure" style="width:80.0%" />
</center>
<p>As can be noticed, we first define the name we want to give to the function.</p>

<div class="rmdwarning">
It is important to make sure that the function name is specific and does not correspond to other functions that may need to be used within your work session. If two functions have the same name, just as with other R objects, the function that will be used is the last one that has been defined within the R working session.
</div>
<p></p>
<p>Once we have defined the name, we then attribute a function to this name by using the <code>function</code> syntax to which we assign some parameters (or attributes). The latter are the values or data that the user will input in order for the function to deliver the desired output. The latter is subsequently obtained through the code constituting the <em>body</em> of the function. Once the code has made the necessary computations, the function needs to know which results are to be given as an output. This can be done, for example, using the <code>return</code> syntax.</p>
<p>A couple of simple examples can be functions that compute the sample mean:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_mean &lt;-<span class="st"> </span>function (x) {
  average &lt;-<span class="st"> </span><span class="kw">sum</span>(x, <span class="dt">na.rm =</span> T)/<span class="kw">sum</span>(!<span class="kw">is.na</span>(x))
  <span class="kw">return</span>(average)
}</code></pre></div>
<p>or multiplies two numbers:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_prod &lt;-<span class="st"> </span>function (a, b) {
  prod &lt;-<span class="st"> </span>a*b
  <span class="kw">return</span>(prod)
}</code></pre></div>
<p>Using these functions, we can compute the sample mean of the annual precipitation in US cities (that can be found in the base R dataset <code>precip</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_mean</span>(precip)</code></pre></div>
<pre><code>## [1] 34.88571</code></pre>
<p>or the product of 265 and 83:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_prod</span>(<span class="dv">265</span>, <span class="dv">83</span>)</code></pre></div>
<pre><code>## [1] 21995</code></pre>
<p>A particular case of function building are so-called “infix” functions that allow to create new operators that carry out specific types of computations. So, instead of defining the name of a function, you can define the symbol to be used in order to make use of that function. For example, to sum two numbers in R you can do as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span> +<span class="st"> </span><span class="dv">2</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>which is simply a predefined infix function that can also be used as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">+</span><span class="st">`</span>(<span class="dv">1</span>, <span class="dv">2</span>)</code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>Therefore the <code>+</code> operator is the result of a predefined infix function in R. However, all user-defined infix functions must start and end with the <code>%</code> symbol. For example, using an operator that we define as <code>%^%</code>, we can deliver the product of two numbers that is zero if the product is actually negative:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">%^%</span><span class="st">`</span> &lt;-<span class="st"> </span>function(a, b) {
  prod =<span class="st"> </span>a*b
  (prod &gt;<span class="st"> </span><span class="dv">0</span>)*prod
}</code></pre></div>
<p>This infix function can now be used through the operator as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> %^%<span class="st"> </span><span class="dv">2</span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> %^%<span class="st"> </span>-<span class="dv">1</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>Having described the general structure of an R function, let us go more into detail by analysing the three main components to R functions:</p>
<ul>
<li><strong>body</strong>: the code lines containing the commands and operations which deliver the desired output;</li>
<li><strong>arguments</strong>: the inputs the user gives to the function which will determine the value or type of output of a function;</li>
<li><strong>environment</strong>: every R function is built within an enviroment of reference from which to source possible input values and/or other functions necessary for it to work.</li>
</ul>
<p>The next sections will therefore go more into detail regarding these components and describe how they contribute to the correct building of a function in R.</p>
</div>
<div id="creating-functions-in-r" class="section level2">
<h2><span class="header-section-number">6.2</span> Creating functions in R</h2>
<p>As an example for the following sections, let us implement a function that takes two arguments and multiplies them according to the type of object they are (i.e. scalar, vector or matrix). To do so, we will first build a skeleton for this function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (...) {
  ...
}</code></pre></div>
<p>As you can see, we find a name for the function we want to build, which in this case is <code>gen_prod</code>, and specify that we are going to attribute a <code>function</code> to this name. Following this assignment, we find a set of curved brackets <code>(...)</code> followed by a set of curly brackets <code>{...}</code> which should include the <em>arguments</em> and <em>body</em> of the function respectively. The next two sections will describe these two components and then discuss the third component which is the function <em>environment</em>.</p>
<div id="function-arguments" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Function arguments</h3>
<p>Before implementing a function, we first need to ask ourselves what is the basic information that we need in order to obtain the desired output. In the case of a general product, as mentioned above, the only information that is essential to perform the operation is the first element and the second element we wish to multiply. These will therefore have to be the elements we need to provide to our function in order for it to deliver the desired product and, in R, we can provide the names we want for them (say <code>first_arg</code> and <code>second_arg</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (first_arg, second_arg) {
  ...
}</code></pre></div>
<p>We will build this function such that the first argument has a higher (or equal) dimension than the second (e.g. the first is a vector while the second is another vector or a scalar). Let us suppose that <code>a = matrix(1:8, 4, 2)</code> is a 4 <span class="math inline">\(\times\)</span> 2 matrix and <code>b = matrix(8:1, 2, 4)</code> is a 2 <span class="math inline">\(\times\)</span> 4 matrix. Given that this is a matrix multiplication, these arguments need to be entered in the correct order (such that the dimensions correspond):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(a, b)</code></pre></div>
<p>In the above syntax, we used so-called <em>positional matching</em> where arguments to the function must be entered in the same order as they are defined in the function itself. If these are entered in the wrong order the function will either give the incorrect output or give errors since the format of the input could be incompatible with the body of the function. In general, it is therefore possible to use positional matching for the first and most important arguments of a function, but it is generally suggested to use names for the arguments. For our function, we could consequently define the arguments as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (<span class="dt">first_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>), 
                      <span class="dt">second_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>)) {
  ...
}</code></pre></div>
<p>You can notice that we assigned the value <code>matrix(rnorm(9), 3, 3)</code> to both of these variables. This is their “default” value which, if not specified otherwise, is used as input for the function (which in this case would deliver a 3 <span class="math inline">\(\times\)</span> 3 matrix result of the product of the two matrices whose elements are generated randomly from a standard normal distribution).</p>
<p>Supposing that we leave the arguments of the functions defined as above, there are different ways to specify these arguments. When calling a function, R first matches the arguments through <em>perfect matching</em>, meaning that it searches for the arguments matching the exact name (in our case “first_arg” and “second_arg”). Failing to match the arguments by their exact name, R then searches for the arguments through <em>prefix matching</em>, meaning that it uses the first letters of the argument names to match them. For example, we could call the function in the following manner:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="dt">second_arg =</span> b, <span class="dt">first_arg =</span> a)</code></pre></div>
<p>or even</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="dt">fi =</span> a, <span class="dt">second =</span> b)</code></pre></div>
<p>So, as long we correctly specify the beginning of the argument’s name and as long as it’s not ambigiuous (meaning that its name cannot be confused with that of another argument), then it is possible to provide only part of the argument’s name and R will recognise and correctly associate the provided value with the corresponding variable.</p>
<p>Finally, failing to match arguments in any of the above cases, R uses positional matching and therefore assigns values to the variables based on the order they have been entered when calling the function. We could therefore go back to using the function like we did at the start by specifying <code>gen_prod(a, b)</code>.</p>

<div class="rmdnote">
It is possible to also specify arguments in terms of the default value of other arguments. For example, we could define the arguments as follows <code>a = matrix(rnorm(9), 3, 3), b = 2*a</code>. There are many other interesting ways of specifying argument values and they can be seen, for example, in <span class="citation">Wickham (<a href="#ref-wickham2014advanced">2014</a>)</span> .
</div>
<p></p>
<p>A special framework in which to specify arguments for a general function is the case where the arguments are objects that belong to a specific class for which a base function can be used. A simple example is the “<code>ts</code>” class of objects in R for which a function exists such that the user simply needs to call the <code>plot()</code> function (without needing to know that the function behind is the <code>plot.ts()</code> function). Let us for example suppose that some function has created a matrix whose elements represent pixel intensities of an image and that this function has assigned a class to this matrix called <code>&quot;pixel&quot;</code>. In the following code we therefore simply assign this class to an object called <code>image</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">image &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rgamma</span>(<span class="dv">100</span>, <span class="dt">shape =</span> <span class="dv">2</span>), <span class="dv">10</span>, <span class="dv">10</span>)
<span class="kw">class</span>(image) =<span class="st"> &quot;pixel&quot;</span></code></pre></div>
<p>If we were to plot this, we would obtain the following plot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(image)</code></pre></div>
<p><img src="ds_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>which simply plots the values for given coordinates. Given that this is not what we want, let us create a function that allows the user to simply use the <code>plot()</code> function which automatically recognises the object and plots a heatmap of the pixel intensity:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plot.pixel &lt;-<span class="st"> </span>function (mat) {
  <span class="kw">suppressWarnings</span>(<span class="kw">heatmap</span>(mat, <span class="dt">Colv=</span><span class="ot">NA</span>, <span class="dt">Rowv=</span><span class="ot">NA</span>, <span class="dt">labRow=</span><span class="ot">NA</span>, <span class="dt">labCol=</span><span class="ot">NA</span>, <span class="dt">scale=</span><span class="st">&#39;none&#39;</span>))
}</code></pre></div>
<p>If we use the <code>plot()</code> function now, we obtain the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(image)</code></pre></div>
<p><img src="ds_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>which produces the desired output simply using the general-purpose function <code>plot()</code>.</p>
<p>To conclude, additional arguments can be left to be specified by the user. This is the case, for example, when there is the possibility of specifying arguments for other functions that are used within the function itself. This can be done by using the argument <code>...</code> which can be added to any function and will match user-specified arguments that do not match the predefined ones in the function. An example of this type of argument is again given by the base <code>plot()</code> function in R where the predefined arguments are <code>x</code> and <code>y</code> (representing the coordinates of the points in the plot) while other optional arguments, such as graphical parameters, can be added taking advantage of the <code>...</code> argument (e.g. the user could specify the argument <code>type = &quot;l&quot;</code> even though this is not included among the specified arguments of the function <code>plot()</code>). This argument is particularly useful when you want to obtain values for other function arguments but don’t want to specify their names in advance.</p>
</div>
<div id="function-body" class="section level3">
<h3><span class="header-section-number">6.2.2</span> Function body</h3>
<p>The body of a function is simply the set of instructions and (possible) other functions that use the arguments provided by the user and computes the desired output. In our case, we need to put into practice a series of tools we learned in the previous chapter (e.g. matrix operations) in order to implement a function that delivers multiplication of objects of different nature. Let us start by delivering the product of the objects <code>first_arg</code> and <code>second_arg</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (<span class="dt">first_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>), 
                      <span class="dt">second_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>)) {
  first_arg%*%second_arg
}</code></pre></div>
<p>If the user doesn’t provide any arguments to the function, this will automatically return a 3 <span class="math inline">\(\times\)</span> 3 matrix (product of two 3 <span class="math inline">\(\times\)</span> 3 matrices built using randomly generated observations from a standard normal). Otherwise, the user can enter the elements of multiplication to obtain their output of interest. For this reason, it would be appropriate that the first and second argument given by the user had compatible dimensions. But what if the latter isn’t the case? When building a function body it is important to consider the possible problems (“bugs”) that could arise if the inputs the user has given cannot be managed by the body of code you have written. For example, let us suppose that the user provides two 3 <span class="math inline">\(\times\)</span> 2 matrices as the first and second arguments:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">6</span>), <span class="dv">3</span>, <span class="dv">2</span>), <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">6</span>), <span class="dv">3</span>, <span class="dv">2</span>))</code></pre></div>
<pre><code>## Error in first_arg %*% second_arg: non-conformable arguments</code></pre>
<p>In this case we see that the function outputs an error and it would be appropriate to insert a checking procedure at the start of our function in order to consider all possible objects that can be multiplied and issue explanations that are useful to the user in order for them to realise what the problem is. We could therefore add a check procedure before we perform the multiplication:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (<span class="dt">first_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>), 
                      <span class="dt">second_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>)) {
  if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">1</span>]) {
    first_arg%*%second_arg
  } else {
    <span class="kw">stop</span>(<span class="st">&quot;Object dimensions are not compatible&quot;</span>)
  }
}</code></pre></div>
<p>As you can see in the example above, we have used a control statement in which we check whether the dimensions for matrix multiplication are respected. If they are, then the function returns the desired product while it returns an error message if this is not the case. The latter is done via the use of the <code>stop()</code> function which outputs the text <code>Error in ...: Object dimensions are not compatible</code> if the dimensions are not compatible:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>),<span class="dv">3</span>,<span class="dv">3</span>), <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">12</span>),<span class="dv">4</span>,<span class="dv">3</span>))</code></pre></div>
<pre><code>## Error in gen_prod(matrix(rnorm(9), 3, 3), matrix(rnorm(12), 4, 3)): Object dimensions are not compatible</code></pre>
<p>When a problem is detected in the body of a function, there may not necessarily be the need to interrupt the execution of the function with an error message. Indeed, in the above example, we could allow the function to check if the number of columns in the second object is compatible with that of the first and, if so, transpose the second matrix in order to obtain the correct multiplication with a warning message notifying the user that this has been done:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (<span class="dt">first_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>), 
                      <span class="dt">second_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>)) {
  if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">1</span>]) {
    first_arg%*%second_arg
  } else {
    if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">2</span>]) {
      <span class="kw">warning</span>(<span class="st">&quot;Second object has been transposed&quot;</span>)
      first_arg%*%<span class="kw">t</span>(second_arg)
    } else {
      <span class="kw">stop</span>(<span class="st">&quot;Object dimensions are not compatible&quot;</span>)
    }
  }
}</code></pre></div>
<p>The function <code>warning()</code> therefore allows to output a result even though there can be some errors in the inputs, notifying the user of the steps made to achieve this output (please type <code>?message</code> to understand what this function allows you to do to communicate with the user). However, let us suppose that the second object entered in this function is a vector. Given our current body in the function we would get the following output:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>),<span class="dv">3</span>,<span class="dv">3</span>), <span class="kw">rnorm</span>(<span class="dv">3</span>))</code></pre></div>
<pre><code>## Error in if (dim(first_arg)[2] == dim(second_arg)[1]) {: argument is of length zero</code></pre>
<p>We obtain this error because the function <code>dim()</code> only works on matrices (not vectors or scalars), therefore we can anticipate this problem by making sure that all objects are considered as matrices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (<span class="dt">first_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>), 
                      <span class="dt">second_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>)) {
  first_arg &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(first_arg)
  second_arg &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(second_arg)
  
  if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">1</span>]) {
    first_arg%*%second_arg
  } else {
    if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">2</span>]) {
      <span class="kw">warning</span>(<span class="st">&quot;Second object has been transposed&quot;</span>)
      first_arg%*%<span class="kw">t</span>(second_arg)
    } else {
      <span class="kw">stop</span>(<span class="st">&quot;Object dimensions are not compatible&quot;</span>)
    }
  }
}</code></pre></div>
<p>which consequently gives us</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>),<span class="dv">3</span>,<span class="dv">3</span>), <span class="kw">rnorm</span>(<span class="dv">3</span>))</code></pre></div>
<pre><code>##            [,1]
## [1,]  1.5688760
## [2,]  0.9404283
## [3,] -1.3263345</code></pre>
<p>Finally, a last check that can be made is whether the second argument is a scalar. Indeed, if the first argument is not scalar, our function would not perform a multiplication:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>),<span class="dv">3</span>,<span class="dv">3</span>), <span class="kw">rnorm</span>(<span class="dv">1</span>))</code></pre></div>
<pre><code>## Error in gen_prod(matrix(rnorm(9), 3, 3), rnorm(1)): Object dimensions are not compatible</code></pre>
<p>although we can always multiply a scalar by a matrix or a vector. Therefore we can add one last control statement:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (<span class="dt">first_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>), 
                      <span class="dt">second_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>)) {
  first_arg &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(first_arg)
  second_arg &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(second_arg)

  if(<span class="kw">dim</span>(second_arg)[<span class="dv">1</span>]==<span class="dv">1</span> &amp;<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">2</span>]==<span class="dv">1</span>) {
    first_arg*second_arg[<span class="dv">1</span>]
  } else {
    if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">1</span>]) {
      first_arg%*%second_arg
    } else {
      if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">2</span>]) {
        <span class="kw">warning</span>(<span class="st">&quot;Second object has been transposed&quot;</span>)
        first_arg%*%<span class="kw">t</span>(second_arg)
      } else {
        <span class="kw">stop</span>(<span class="st">&quot;Object dimensions are not compatible&quot;</span>)
      }
    }
  }
}</code></pre></div>
<p>which allows us to have</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gen_prod</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>),<span class="dv">3</span>,<span class="dv">3</span>), <span class="kw">rnorm</span>(<span class="dv">1</span>))</code></pre></div>
<pre><code>##            [,1]        [,2]         [,3]
## [1,]  0.1109147  0.34554306  0.073493133
## [2,]  0.3518729 -0.03639988 -0.133107114
## [3,] -0.8289219  0.28413926 -0.001721236</code></pre>

<div class="rmdimportant">
Additional check procedures should be carried out in order to understand if the first object has equal or higher dimensions compared to the second (although the user should be made aware of this in the description of the function). However we leave this exercise to the reader since it would simply be redundant in the message conveyed on programming the body of a function.
</div>
<p></p>
<p>As you can see, the body of a function can rapidly become lengthy and complex when adding control statements and computations to it. This can become an issue if you program a complex function and then have to share it with a collaborator or modify it after some time you haven’t used it. It is therefore good practice to comment your functions and make sure that the objects consisting in the output of your function are clear to someone who reads the function. In the latter case, the <code>return()</code> function makes sure that only the objects that you’re interested in are returned to the user (avoiding that eventual unassigned and unimportant values are returned).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gen_prod &lt;-<span class="st"> </span>function (<span class="dt">first_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>), 
                      <span class="dt">second_arg =</span> <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">9</span>), <span class="dv">3</span>, <span class="dv">3</span>)) {
  
  <span class="co"># Make sure that all objects are considered as matrices</span>
  first_arg &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(first_arg)
  second_arg &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(second_arg)
  
  <span class="co"># Check if second argument is a scalar and, if so, return product (prod)</span>
  if(<span class="kw">dim</span>(second_arg)[<span class="dv">1</span>]==<span class="dv">1</span> &amp;<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">2</span>]==<span class="dv">1</span>) {
    prod &lt;-<span class="st"> </span>first_arg*second_arg[<span class="dv">1</span>]
  }else{
    <span class="co"># Check if the objects have compatible dimensions and, if so, return product (prod)</span>
    if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">1</span>]) {
      prod &lt;-<span class="st"> </span>first_arg%*%second_arg
    }else{
      <span class="co"># Check if other dimensions are compatible if the initial</span>
      <span class="co"># ones are not and, if so, transpose the second object and return </span>
      <span class="co"># product (prod) with warning for the user</span>
      if (<span class="kw">dim</span>(first_arg)[<span class="dv">2</span>] ==<span class="st"> </span><span class="kw">dim</span>(second_arg)[<span class="dv">2</span>]) {
        <span class="kw">warning</span>(<span class="st">&quot;Second object has been transposed&quot;</span>)
        prod &lt;-<span class="st"> </span>first_arg%*%<span class="kw">t</span>(second_arg)
      } else {
        <span class="co"># Output an error message if none of the dimensions are compatible</span>
        <span class="kw">stop</span>(<span class="st">&quot;Object dimensions are not compatible&quot;</span>)
      }
    }
  }
  <span class="kw">return</span>(prod)
}</code></pre></div>
</div>
</div>
<div id="function-environment" class="section level2">
<h2><span class="header-section-number">6.3</span> Function environment</h2>
<p>Generally speaking, an environment is a virtual space in which certain names are associated to specific objects and values. The main characterstics of an environment are the following (see <a href="http://adv-r.had.co.nz/Environments.html">Wickham: Environments</a>):</p>
<ul>
<li>Every name in an environment is unique</li>
<li>Every environment has a parent</li>
</ul>
<p>The second characteristic means that when working within a given environment, you’re also working in an environment (parent) which includes that environment. For example, in R the usual environment one works in is the “global environment” and its parent is the last package that has been loaded in the R session while the “base environment” is a special case of the global environment and is the environment of the base package (whose parent is the empty environment).</p>
<p>Within this structure, also functions have their own types of environments. Based on this structure, functions will look for the names of objects (and associated values) through scoping methods that start within the function’s environment and then, if these are not found, proceed to looking for the names in the parent environments. The types of environments for R functions are the following:</p>
<ul>
<li>Enclosing: this is the environment in which the function was created (usually the global environment) and each function only has one enclosing environment</li>
<li>Binding: this is the environment in which the function is associated to a given name (usually the enclosing and binding environment are the same)</li>
<li>Execution: this environment is created each time a function is called and in which the objects created by this function during execution are stored</li>
<li>Calling: this environment is associated with the execution environment and reports the environment in which a function was called</li>
</ul>
<p>First of all, the enclosing environment of a function can be found by using the <code>environment()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">environment</span>(gen_prod)</code></pre></div>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>With this function therefore informs the user on the enclosing environment and its main difference with the binding environment consists in the fact that the first determines how to find values (lexical scoping) while the second determines how to find the function. The reason for this separation (at least one of the main reasons) lies in the need to separate package namespaces. By the latter we mean, for example, the case where packages have the same names for different functions, allowing to preserve the name of the function in the enclosing environment unless otherwise specified. An example can be given with the <code>var()</code> function (to compute the variance) which uses the <code>missing()</code> function (in the base package) to check if a value is specified as an argument to a function (check with <code>?missing</code>). Let us suppose we compute the variance of a vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">9</span>)
<span class="kw">var</span>(x)</code></pre></div>
<pre><code>## [1] 6.8</code></pre>
<p>Let us now create another function called <code>missing</code> in the global environment which takes <code>x</code> as an argument but only returns 100. After this, we execute the code above again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">missing =<span class="st"> </span>function (x) <span class="dv">100</span>
x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">9</span>)
<span class="kw">var</span>(x)</code></pre></div>
<pre><code>## [1] 6.8</code></pre>
<p>The result is always the same although the <code>var()</code> function would have halted execution if it had considered our own <code>missing()</code> function. This is possible thanks the to the package namespace which keeps packages independent through the separate use of enclosing and binding environments.</p>
<p>Finally, the execution environment allows to create a temporary environment in which the function can create its objects without affecting the environment in which it is created and called. For example, suppose that we call our <code>gen_prod</code> function but, before doing so, we define an object called <code>prod</code> and assign a value to it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">prod &lt;-<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>We know that our <code>gen_prod()</code> function creates an object with the same name and, according to standard R programming rules, the new object with the same name should overwrite the previous one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">output &lt;-<span class="st"> </span><span class="kw">gen_prod</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">100</span>), <span class="dv">10</span>, <span class="dv">10</span>), <span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">100</span>), <span class="dv">10</span>, <span class="dv">10</span>))
prod</code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>As can be seen, although our <code>gen_prod()</code> function defines the object <code>prod</code>, this quantity remains in the execution environment and does not affect or modify the environment in which is it called (calling environment) and is removed once the function has completed execution.</p>
</div>
<div id="example-continued-least-squares-function" class="section level2">
<h2><span class="header-section-number">6.4</span> Example (continued): Least-squares function</h2>
<p>To implement our linear regression function we need to understand the algebra behind least squares and make use of the matrix operations in R explained in the previous chapter. Based on the linear algebra behind least-squares regression, let us implement a function that delivers inference on the parameter vector <span class="math inline">\(\boldsymbol{\beta}\)</span> and therefore define the skeleton of this R function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm &lt;-<span class="st"> </span>function (...) {
  
  ...
  
}</code></pre></div>
<p>As you can see, we find a name for the function we want to build, which in this case is <code>my_lm</code>, and specify that we are going to attribute a <code>function</code> to this name. Following this assignment, we find a set of curved brackets <code>(...)</code> followed by a set of curly brackets <code>{...}</code> which should include the <em>arguments</em> and <em>body</em> of the function respectively. While the <em>body</em> of a function simply corresponds to all the command lines (and other functions) that are used to deliver an output, the next sections will tackle function arguments as well as other important aspects such as their environment and attributes.</p>
<p>In the framework of linear regression the goal is to explain an <span class="math inline">\(n \times 1\)</span> vector of observations <span class="math inline">\(\mathbf{y}\)</span> (representing the response variable) through a linear combination of <span class="math inline">\(p\)</span> explanatory variables (or predictors or covariates) that are stored in an <span class="math inline">\(n \times p\)</span> matrix <span class="math inline">\(\mathbf{X}\)</span>. More specifically, the framework is the following:</p>
<p><span class="math display">\[
\mathbf{y} = \mathbf{X}^T\boldsymbol{\beta} + \mathbf{\epsilon},
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\beta}\)</span> is the <span class="math inline">\(p \times 1\)</span> parameter vector of interest that links the covariates with the response variable while <span class="math inline">\(\mathbf{\epsilon}\)</span> is the <span class="math inline">\(n \times 1\)</span> random error vector with null expectation and variance <span class="math inline">\(\sigma^2\)</span>.</p>
<p>When we collect data for the purpose of linear regression, the unknown terms in the above setting are the parameter vector <span class="math inline">\(\boldsymbol{\beta}\)</span> and the variance parameter <span class="math inline">\(\sigma^2\)</span>. In order to estimate <span class="math inline">\(\boldsymbol{\beta}\)</span>, assuming that the matrix <span class="math inline">\(\left(\mathbf{X}^T \mathbf{X}\right)^{-1}\)</span> exists, the least-squares estimator for it is given by:</p>
<span class="math display" id="eq:lsformula">\[\begin{equation}
  \hat{\boldsymbol{\beta}} = \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T \mathbf{y}
\tag{6.1}
\end{equation}\]</span>
<p>If you are interested in understanding how Eq. <a href="functions.html#eq:lsformula">(6.1)</a> is derived, click on the button. If you’re not familiar with such calculations we suggest you read some introduction to linear regression <span class="citation">(see for example Seber and Lee <a href="#ref-seber2012linear">2012</a>)</span>.</p>
<button id="hidebutton1">
Derivation of Least-Squares Estimator
</button>
<div id="hideclass1">

<div class="rmdtip">
<p>The least-square estimator <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is given by</p>
<span class="math display">\[\begin{equation*}
 \hat{\boldsymbol{\beta}} = \operatorname{argmin}_{\boldsymbol{\beta}} \; \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right) 
\end{equation*}\]</span>
<p>The first step of this derivation is to reexpress the term <span class="math inline">\(\left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right)\)</span> as follows:</p>
<span class="math display">\[\begin{equation*}
    \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right) =  \mathbf{y}^T\mathbf{y} +  \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X} \boldsymbol{\beta} - 2 \boldsymbol{\beta}^T \mathbf{X}^T \boldsymbol{y}.
\end{equation*}\]</span>
<p>In case you were suprizied by the term <span class="math inline">\(2 \boldsymbol{\beta}^T \mathbf{X}^T \boldsymbol{y}\)</span> remeber that a scalar can always be transposed without changing its value and therefore we have that $ ^T ^T  = ^T  $. Now, our next step is to the following derivative</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right).
\end{equation*}\]</span>
<p>To do this we should keep in mind the following results</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \boldsymbol{\beta}^T \mathbf{X}^T \boldsymbol{y} =   
   \boldsymbol{y}^T \mathbf{X},
\end{equation*}\]</span>
<p>and</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X} \boldsymbol{\beta} =  2 \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X}.
\end{equation*}\]</span>
<p>The proof of these two results can for example be found in Propositions 7 and 9 of <a href="http://www.atmos.washington.edu/~dennis/MatrixCalculus.pdf">Prof. Barnes’ notes</a>. Using these two results we obtain</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right) = 2 \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X} - 2 \boldsymbol{y}^T \mathbf{X}.
\end{equation*}\]</span>
<p>By solving for the first order condition (and under some technical assumptions not discussed here) we can redefine <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> through the follwing equation</p>
<span class="math display">\[\begin{equation*}
  \hat{\boldsymbol{\beta}}^T \mathbf{X}^T \mathbf{X} =  \boldsymbol{y}^T \mathbf{X},
\end{equation*}\]</span>
<p>which is equivalent to</p>
<span class="math display">\[\begin{equation*}
  \mathbf{X}^T \mathbf{X} \hat{\boldsymbol{\beta}} =   \mathbf{X}^T \boldsymbol{y}.
\end{equation*}\]</span>
<p>If <span class="math inline">\(\left(\mathbf{X}^T \mathbf{X}\right)^{-1}\)</span> exists, <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is therefore given by</p>
<span class="math display">\[\begin{equation*}
  \hat{\boldsymbol{\beta}} = \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T \mathbf{y},
\end{equation*}\]</span>
which verifies Eq. <a href="functions.html#eq:lsformula">(6.1)</a>.
</div>
<p></p>
</div>
<p></p>
<p>The variance of <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is given by</p>
<span class="math display" id="eq:lsvar">\[\begin{equation}
\text{Var} \left(\hat{\boldsymbol{\beta}} \right) = \sigma^2 \left(\mathbf{X}^T \mathbf{X}\right)^{-1},
\tag{6.2}
\end{equation}\]</span>
<p>and if you are interested, you can click on the button below to see how this formula was derived.</p>
<button id="hidebutton2">
Derivation - Variance of Least-Squares Estimator
</button>
<div id="hideclass2">

<div class="rmdtip">
<p>If we let <span class="math inline">\(\mathbf{A} = \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T\)</span>, then we have</p>
<span class="math display">\[\begin{equation*}
\begin{aligned}
  \text{Var} \left(\hat{\boldsymbol{\beta}} \right) &amp;= \text{Var} \left( \mathbf{A} \mathbf{y} \right) = \mathbf{A} \text{Var} \left(  \mathbf{y} \right) \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{A}^T \\
  &amp; = \sigma^2 \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T  \mathbf{X} \left(\mathbf{X}^T \mathbf{X}\right)^{-1} = \sigma^2 \left(\mathbf{X}^T \mathbf{X}\right)^{-1},
\end{aligned}
\end{equation*}\]</span>
<p>which verifies Eq. <a href="functions.html#eq:lsvar">(6.2)</a>. To understand the above derivation it may be useful to remind and point out a few things:</p>
<ul>
<li><span class="math inline">\(\text{Var} \left( \mathbf{A} \mathbf{y} \right) = \mathbf{A} \text{Var} \left( \mathbf{y} \right) \mathbf{A}^T\)</span> since <span class="math inline">\(\mathbf{A}\)</span> is not a random variable.</li>
<li><span class="math inline">\(\mathbf{A} \text{Var} \left( \mathbf{y} \right) \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{A}^T\)</span> since<span class="math inline">\(\text{Var} \left( \mathbf{y} \right) = \sigma^2 \mathbf{I}\)</span> and therefore we have <span class="math inline">\(\mathbf{A} \text{Var} \left( \mathbf{y} \right) \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{I} \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{A}^T\)</span>.</li>
<li>The result <span class="math inline">\(\mathbf{A} \mathbf{A}^T = (\mathbf{X}^T \mathbf{X})^{-1}\)</span> is based on the fact that <span class="math inline">\((\mathbf{X}^T \mathbf{X})^{-1}\)</span> is symmetric but this is not necessarily intuitive. Indeed, this follows from the fact that any square and invertible matrix <span class="math inline">\(\mathbf{B}\)</span> is such that the inverse and transpose operator commute, meaning that <span class="math inline">\(( \mathbf{B}^T )^{-1} = ( \mathbf{B}^{-1} )^T\)</span>. Therefore since the matrix <span class="math inline">\(\mathbf{X}^T \mathbf{X}\)</span> is square and (by assumption) invertible we have <span class="math inline">\([(\mathbf{X}^T \mathbf{X})^{-1}]^T = [(\mathbf{X}^T \mathbf{X})^{T}]^{-1} = ( \mathbf{X}^T \mathbf{X})^{-1}\)</span>.
</div>
</li>
</ul>
</div>
<p></p>
<p>In general, the residual variance is unknown and needs to be estimated. A common and unbiased estimator of <span class="math inline">\(\sigma^2\)</span> is given by</p>
<span class="math display" id="eq:lssig2hat">\[\begin{equation}
  \hat{\sigma}^2 = \frac{1}{n - p}  \left( \mathbf{y} - \mathbf{X}\hat{\boldsymbol{\beta}} \right)^T \left( \mathbf{y} - \mathbf{X} \hat{\boldsymbol{\beta}}\right) 
  \tag{6.3}
\end{equation}\]</span>
<!-- DO YOU GUYS THINK WE SHOULD SHOW THE UNBIASEDNESS IN BOX HERE. THIS IS A LITTLE MORE ADVANCED AS WE NEED TO USE PROJECTION MATRICES AND THEIR PROPERTIES. LET ME KNOW. -->
<!-- ROB COMMENT: Maybe I'd ask them to show the unbiasdness as homework either theoretically or giving numerical support to the claim (e.g. the mean of different beta hats is close to the true beta) -->
<!-- JUSTIN COMMENT: I agree with Rob's suggestion :)  -->
<p>The rest of this section aims at implementing Eq. <a href="functions.html#eq:lsformula">(6.1)</a> to <a href="functions.html#eq:lssig2hat">(6.3)</a>.</p>
<p>Putting aside possible problems with the data that would require a more in-depth knowledge and discussion of linear regression theory, we can proceed to estimate the Hubble constant by using the velocity as the response variable <span class="math inline">\(y\)</span> and the distance as the explanatory variable <span class="math inline">\(x\)</span>. Let us therefore start by implementing Eq. <a href="functions.html#eq:lsformula">(6.1)</a> within our function in order to get an estimate of <span class="math inline">\(\beta\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates) {
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (6.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Return the estimated value of beta</span>
  beta.hat
}</code></pre></div>

<div class="rmdimportant">
Before discussing the body and output of this function, we can first underline an important aspect of programming. Indeed, we defined the number of covariates (and length of the vector <span class="math inline">\(\boldsymbol{\beta}\)</span>) as <code>p &lt;- dim(covariates)[2]</code> where the function <code>dim()</code> presupposes that the object <code>covariates</code> is a matrix. Nevertheless, in our case the object <code>covariates</code> would correspond to <code>hubble$x</code> which is a vector and therefore this operation would return <code>NULL</code> as an output. When programming it is therefore important to think ahead and understand if there are any particular cases where parts of the body of your function may not work.
</div>
<p></p>
<p>Taking into account the above note, it would be appropriate to make sure that the code in the body of the function works also in particular cases (e.g. the <code>covariates</code> object is a vector and not a matrix). In our case we therefore use the function <code>as.matrix()</code> which forces an object to be considered as a matrix in order for it to be used within matrix opeations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates) {
  
  <span class="co"># Make sure data formats are appropriate</span>
  response &lt;-<span class="st"> </span><span class="kw">as.vector</span>(response)
  covariates &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(covariates)
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (6.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Return the estimated value of beta</span>
  beta.hat
}</code></pre></div>

<div class="rmdtip">
Other checks can be introduced at the beginning of the function to make sure that the function is used correctly and obtain an appropriate output. In our case, for example, we could even introduce a check to understand if <code>response</code> and <code>covariates</code> have the same number of rows and interrupt the function execution and output an error message if this is not the case, making the user aware of this probem.
</div>
<p></p>
<p>As you may notice, using the matrix operators we obtain an object we decide to call <code>beta.hat</code> and, to tell the function to return this value, we simply specify it without any other commands after it has been computed. A more appropriate way of defining the outputs of a function would however be the <code>return()</code> function that avoids ambiguous outputs due to mistakes in coding or others within the function body. By using <code>return()</code> we make sure the desired outputs are given and it improves readability of the function for other users (see the next example further on).</p>
<p>With the <code>my_lm()</code> function we can now estimate the value for <span class="math inline">\(\beta\)</span> that we denote as <span class="math inline">\(\hat{\beta}\)</span>. However, we don’t have an estimate of its variance for which we would need to implement Equations <a href="functions.html#eq:lsvar">(6.2)</a> and <a href="functions.html#eq:lssig2hat">(6.3)</a>. We can therefore add these equations to the body of our <code>my_lm()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates) {
  
  <span class="co"># Make sure data formats are appropriate</span>
  response &lt;-<span class="st"> </span><span class="kw">as.vector</span>(response)
  covariates &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(covariates)
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (6.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Estimate of the residual variance (sigma2) from Eq. (6.3)</span>
  <span class="co"># Compute residuals</span>
  resid &lt;-<span class="st"> </span>response -<span class="st"> </span>covariates%*%<span class="kw">as.matrix</span>(beta.hat)
  sigma2.hat &lt;-<span class="st"> </span>(<span class="dv">1</span>/df)*<span class="kw">t</span>(resid)%*%resid
  
  <span class="co"># Estimate of the variance of the estimated beta from Eq. (1.2)</span>
  var.beta &lt;-<span class="st"> </span>sigma2.hat*<span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)
  
  <span class="co"># Return all estimated values</span>
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">beta =</span> beta.hat, <span class="dt">sigma2 =</span> sigma2.hat, <span class="dt">variance_beta =</span> var.beta))
}</code></pre></div>
<p>There are a couple of things to underline in the above function. Firstly, when defining the <code>resid</code> object we also used <code>as.matrix()</code> for the object <code>beta.hat</code>: this is because it can happen (as in our example) that the dimension of <span class="math inline">\(\boldsymbol{\beta}\)</span> could be equal to one (i.e. a scalar) and the matrix multiplication would not work and output an error. By using the <code>as.matrix()</code> function, we ensure that this multiplication will work also when <span class="math inline">\(\boldsymbol{\beta}\)</span> is a scalar (i.e. when there is only one covariate). A second aspect to underline is the way in which we return multiple function outputs. Indeed, in our case we decide to return not only the estimate of <span class="math inline">\(\beta\)</span> but also the estimated residual variance as well as the variance of <span class="math inline">\(\hat{\beta}\)</span>. To do so, we use the <code>list()</code> function that allows to store objects of different nature (e.g. scalars, vectors, matrices) as elements of a single object while assigning names to them. For example, the estimated parameter <span class="math inline">\(\beta\)</span> will be accessible through the element name <code>beta</code> (we’ll see how this done further on).</p>
<p>Nevertheless, in order to answer the question of our example on the Hubble constant, we would need to obtain a confidence interval for our estimated paramter <span class="math inline">\(\hat{\beta}\)</span>. Although the information needed for this purpose is available to the user through the current output, it may be useful to directly provide the confidence interval since it is a piece of information which is almost always required to deliver inference on the true parameter <span class="math inline">\(\beta\)</span>. Let us therefore build a confidence interval within our function for which we will assume that the estimated variance of <span class="math inline">\(\hat{\beta}\)</span> is actually the true variance (otherwise we would need to build a confidence interval based on the Student-t distribution which we will not deal with at this stage of our course). Assuming therefore that</p>
<span class="math display">\[\begin{equation*}
  \hat{\beta} \sim \mathcal{N}\left(\beta,\hat{\sigma}^2(X^TX)^{-1}\right) ,
\end{equation*}\]</span>
<p>we consequently have that the confidence interval is given by</p>
<span class="math display" id="eq:cibeta">\[\begin{equation}
  \left[\hat{\beta} - z_{1-\alpha/2}\sqrt{\hat{\sigma}^2(X^TX)^{-1}} \, , \, \hat{\beta} + z_{1-\alpha/2}\sqrt{\hat{\sigma}^2(X^TX)^{-1}} \right] ,
  \tag{6.4}
\end{equation}\]</span>
<p>where <span class="math inline">\(z_{1-\alpha/2}\)</span> is the <span class="math inline">\((1-\alpha/2)^{th}\)</span> quantile of the standard normal distribution.</p>
<p>Let us therefore add this output to our function which would require an extra argument: the confidence level. The most common confidence level used is the 95% level which is obtained by defining the significance level <span class="math inline">\(\alpha = 0.05\)</span>. We could therefore add the latter argument to our function and set its default value to 0.05.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates, <span class="dt">alpha =</span> <span class="fl">0.05</span>) {
  
  <span class="co"># Make sure data formats are appropriate</span>
  response &lt;-<span class="st"> </span><span class="kw">as.vector</span>(response)
  covariates &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(covariates)
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (6.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Estimate of the residual variance (sigma2) from Eq. (6.3)</span>
  <span class="co"># Compute residuals</span>
  resid &lt;-<span class="st"> </span>response -<span class="st"> </span>covariates%*%<span class="kw">as.matrix</span>(beta.hat) 
  sigma2.hat &lt;-<span class="st"> </span>(<span class="dv">1</span>/df)*<span class="kw">t</span>(resid)%*%resid
  
  <span class="co"># Estimate of the variance of the estimated beta from Eq. (6.2)</span>
  var.beta &lt;-<span class="st"> </span>sigma2.hat*<span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)
  
  <span class="co"># Estimate of the confidence interval based on alpha</span>
  quant &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>alpha/<span class="dv">2</span>
  ci.beta &lt;-<span class="st"> </span><span class="kw">c</span>(beta.hat -<span class="st"> </span><span class="kw">qnorm</span>(<span class="dt">p =</span> quant)*<span class="kw">sqrt</span>(var.beta), beta.hat +<span class="st"> </span>
<span class="st">                 </span><span class="kw">qnorm</span>(<span class="dt">p =</span> quant)*<span class="kw">sqrt</span>(var.beta))
  
  <span class="co"># Return all estimated values</span>
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">beta =</span> beta.hat, <span class="dt">sigma2 =</span> sigma2.hat, 
              <span class="dt">variance_beta =</span> var.beta, <span class="dt">ci =</span> ci.beta))
}</code></pre></div>
<p>We now have now a general function to perform linear regression which has a series of scalar outputs as well as a vector (i.e. the confidence interval). Let us now complete this chapter by investigating how the <code>my_lm()</code> function performs compared to the base <code>lm()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Linear regression with lm() function</span>
fit_lm =<span class="st"> </span><span class="kw">lm</span>(hubble$y~hubble$x<span class="dv">-1</span>)

<span class="co"># Linear regression with my_lm() function</span>
fit_my_lm =<span class="st"> </span><span class="kw">my_lm</span>(hubble$y, hubble$x)

<span class="co"># Compare outputs</span>
manual_results =<span class="st"> </span><span class="kw">c</span>(fit_my_lm$beta, fit_my_lm$sigma2)
base_results =<span class="st"> </span><span class="kw">c</span>(fit_lm$coefficients, 
                     (<span class="dv">1</span>/fit_lm$df.residual)*<span class="kw">t</span>(fit_lm$residuals)%*%fit_lm$residuals)
results =<span class="st"> </span><span class="kw">cbind</span>(manual_results, base_results)
<span class="kw">row.names</span>(results) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Beta&quot;</span>, <span class="st">&quot;Sigma&quot;</span>)
results</code></pre></div>
<pre><code>##       manual_results base_results
## Beta        76.58117     76.58117
## Sigma    67046.33165  67046.33165</code></pre>
<p>As one can notice, the two procedures give the same outputs indicating that our <code>my_lm()</code> function well implements the linear regression method. We can now proceed to use our function in order to test the Creationist hypothesis on the age of the universe assuming the validity of the big bang theory. First of all, due to different measurement units we perform a unit transformation and then compute the age in years (which requires an additional transformation since the previous one gives a unit of <span class="math inline">\(s^{-1}\)</span>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Estimated Hubble&#39;s constant</span>
hubble_const &lt;-<span class="st"> </span>fit_my_lm$beta/<span class="fl">3.09e19</span> 
<span class="co"># Note: The estimated Hubble&#39;s constant in inverse seconds, [s^(-1)]</span>

<span class="co"># Age of the universe in seconds</span>
age_sec &lt;-<span class="st"> </span><span class="dv">1</span>/hubble_const 

<span class="co"># Age of the universe in years</span>
age_sec/(<span class="dv">60</span>^<span class="dv">2</span>*<span class="dv">24</span>*<span class="dv">365</span>) </code></pre></div>
<p>Based on this estimation, the age of the universe appears to be almost 13 billion years. However, we know that <span class="math inline">\(\hat{\beta}\)</span> is a random variable that therefore follows a distribution which, based on asymptotic statistical theory, is a normal distribution with expectaton <span class="math inline">\(\beta\)</span> and variance <span class="math inline">\(\sigma^2(X^TX)^{-1}\)</span>.</p>
<p>Now, let’s suppose that we have a hypothesis on the age of the universe, for example that of Creation Scientists who claim that the universe is 6000 years old based on a reading from the Bible. Assuming the validity of the big bang theory, which is not the case for Creation Scientists, let us nevertheless test if their claim appears to be reasonable within this postulated framework. For this purpose we can build a 95% confidence interval for the true Hubble constant <span class="math inline">\(\beta\)</span> and understand if the Hubble constant implied by the postulated age of the universe falls within this interval. Firstly, we can determine this constant under the null hypothesis which can be defined as follows</p>
<span class="math display">\[\begin{equation*}
  H_0 \, : \, \beta = 163 \times 10^6 ,
\end{equation*}\]</span>
<p>since this value of <span class="math inline">\(\beta\)</span> would imply that the universe is roughly 6000 years old. The alternative hypothesis is that the true <span class="math inline">\(\beta\)</span> is not equal to the above quantity (i.e. <span class="math inline">\(H_A \, : \, \beta \neq 163 \times 10^6\)</span>). … Let us therefore replace the values in Eq. <a href="functions.html#eq:cibeta">(6.4)</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 95% confidence interval for the Hubble constant</span>
fit_my_lm$ci</code></pre></div>
<pre><code>## [1] 68.81032 84.35203</code></pre>
<p>The confidence interval lies between 68 and 84 which clearly does not contain the value implied by the age of the universe postulated by the Creation Scientists. Hence, assuming the validity of the big bang theory, we can reject this hypothesis at a 95% level.</p>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript">
    $("#hideclass1").hide();
    $("#hideclass2").hide();
    $("#hidebutton1").click(function(){
      $("#hideclass1").toggle();
    });
    $("#hidebutton2").click(function(){
      $("#hideclass2").toggle();
    });
</script>

</div>
</div>
<h3> Placeholder</h3>
<div id="refs" class="references">
<div id="ref-wood2017generalized">
<p>Wood, Simon N. 2017. <em>Generalized Additive Models: An Introduction with R</em>. CRC press.</p>
</div>
<div id="ref-wickham2014advanced">
<p>Wickham, Hadley. 2014. <em>Advanced R</em>. CRC Press. <a href="http://adv-r.had.co.nz/" class="uri">http://adv-r.had.co.nz/</a>.</p>
</div>
<div id="ref-seber2012linear">
<p>Seber, George AF, and Alan J Lee. 2012. <em>Linear Regression Analysis</em>. Vol. 936. John Wiley &amp; Sons.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>This scheme is inspired from diagrams by Prof. Bob Rudis and James Balamuta.<a href="functions.html#fnref1">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="control.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="placeholder.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/05-functions.Rmd",
"text": "Edit"
},
"download": ["ds.pdf", "ds.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
