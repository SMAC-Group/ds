[
<<<<<<< HEAD
["control.html", "Chapter 5 Control Structures 5.1 Introduction 5.2 Selection control statements", " Chapter 5 Control Structures 5.1 Introduction When you’re building a larger or more complex program than the examples we considered previously, we need to use various control structures to control the “flow” of our actions. Essentially, a control structure is a “block” of code that analyzes variables and chooses a direction in which to go based on given parameters. These pieces of code represent the most basic decision-making processes in computing. There exist essentially two kinds of control structures. The first one allows to determine whether a given condition is satisfied and select an appropriate response. A simple analogy to our day-to-day life would be “if it’s raining outside, then take an umbrella” (we will come back to this example in the next section). The second kind of control structure allows to repeat of a block of code multiple times. For example, such an approach can be used to convert a color image to a gray-scale by applying the same operation(s) (i.e. same code) to each pixel of the image. In this chapter, we will first discuss the two kinds of control structures previously mentioned and then present various examples to help build our intuition. 5.2 Selection control statements Suppose that we are interested in creating a simple code to check if it rained over the last hour and, if this is the case, lead us to decide whether we should take an umbrella today. To write such a code we essentially need three things: Find out how much it rained in the last hour at our location. Such information is now easily accessible through various websites and we can for example used the R package rwunderground to access this information. Note that you will need to create an account and request an API key before being able to use it (see package documentation for more details). Then, the amount of precipitation (in inches) in the last hour can be retrieved using the code below: library(rwunderground) (rain &lt;- conditions(set_location(zip_code = &quot;16802&quot;), message = FALSE)$precip_1hr) ## [1] 0 Construct a logical (or Boolean) variable created from the variable rain to assess whether or not an umbrella is needed. For example, we can say that if we see signs of rain in the last hour, then we should take an umbrella. This can be done using the code below and in Section @ref(logical_operators) we will discuss how to construct logical variables in more detail. (umbrella &lt;- rain &gt; 0) ## [1] FALSE Finally, we need to select operators based on the logical variables constructed in the previous step to bring everything together. For example, we could use the if/else statement presented below. This simple code will print “You should probably take an umbrella” if the logical variable umbrella is TRUE and print “An umbrella is probably not necessary”, otherwise. if (umbrella){ print(&quot;You should probably take an umbrella&quot;) }else{ print(&quot;An umbrella is probably not necessary&quot;) } ## [1] &quot;An umbrella is probably not necessary&quot; 5.2.1 Logical Operators Logical operators are very commonly used in programming to create (or return) logical (boolean) variables. In general, logical operations take place by comparing one or more variables following specific rules. The table below summarizes the commonly used logical operators: Command Description Example Result x &gt; y x greater than y 4 &gt; 3 TRUE x &gt;= y x greater or equals to y 1 &gt;= 1 TRUE x &lt; y x less than y c(12 &lt; 20, 1 &lt; 1) TRUE, FALSE x &lt;= y x less than or equals to y 12 &lt;= 1 FALSE x == y x equal to y c(2 == 2, 1 == 2) TRUE, FALSE x != y x not equal to y c(2 != 2, F != T) FALSE, TRUE !x Not x c(!(2 &gt; 1), !FALSE) FALSE, TRUE x ||y x or y (not vectorized) (1 &gt; 1) || (2 &lt; 3) TRUE x |y x or y (vectorized) c(1 &gt; 1, F) || c(T, 2 &lt; 3) TRUE x &amp;&amp; y x and y (not vectorized) TRUE &amp;&amp; TRUE TRUE x &amp; y x and y (vectorized) c(TRUE, T) &amp; c(TRUE, F) TRUE, FALSE xor(x,y) test if only one is TRUE xor(TRUE, TRUE) FALSE all(x) test if all are TRUE all(c(T, F, F)) FALSE any(x) test if one or more is TRUE any(c(T, F, F)) TRUE There is a subtle difference between ||and | (or &amp;&amp; and &amp;). Indeed, when using x &amp;&amp; y or x || y it implicitly assumes that x and yare of length 1 and when these are applied to vectors only the first elements of each vector will be considered. For example, c(TRUE,FALSE) || c(FALSE, FALSE) is equivalent to TRUE || FALSE and will only return TRUE. On the other hand, &amp; and | can be applied to vectors and c(TRUE,FALSE) || c(FALSE, FALSE) is equivalent to c(TRUE || FALSE, FALSE || FALSE) and will return TRUE FALSE. It is also worth mentioning that TRUE | c(FALSE, FALSE) is equivalent to c(TRUE || FALSE, TRUE || FALSE) (i.e. the TRUE is used twice) and will return TRUE TRUE. These differences are a common source of bugs. When using &amp; or | to create/return logical variables we have to be aware of something called short-circuit evaluation which can create bugs that may be difficult to find. Indeed, suppose that we interested in using an expression such as x &amp; y and that if the variable x is FALSE then y will not be evaluated. The idea behind this evaluation is that, regardless of the value of y, the expression x &amp; y should be TRUE. However, this implicitly assumes that y does not contain any mistakes and if this were indeed to be the case, this could create bugs that would be hard to find. For example, consider the expression y = x &amp;&amp; 2 == NULL, then if x is FALSE y will be FALSE while if x is TRUE y will be NA, which obviously is likely to be problematic. Similarly, when considering an expression such as x | y, the variable y will only be evaluated if x is FALSE. y ``` ``` ## [1] TRUE TRUE FALSE FALSE FALSE ``` This method outputs a vector of boolean TRUE and FALSE values that perform element-wise comparisons. Note, this is called a vectorized method, which we will further mention in more details later. `isTRUE()` checks if all the elements within the object is `TRUE`. ```r isTRUE(TRUE) ``` ``` ## [1] TRUE ``` ```r isTRUE(x>y) ``` ``` ## [1] FALSE ``` --> 5.2.2 Selection Operators Selection operators govern the flow of code. We can observe if/else statements everywhere, no matter what language. 5.2.2.1 if Statements The most basic selection operator is called an if statement. Essentially, an if statement tells R to do a certain task for a certain case. In plain English it would correspond to something like, “If this is true, do that” or as in our motivating example “If it rains take an umbrella”. In R, you would say: if (&lt;this is TRUE&gt;){ &lt;do that&gt; } or if (&lt;it rains&gt;){ &lt;take an umbrella&gt; } In general, we can represent an if statement using the following diagram: The &lt;conditon&gt; denotes a logical variable that is used determine if the code inside of { } will be evaluated. For example, if &lt;condition&gt; is FALSE then our program will run Code block A and then Code block C. On the other hand, if &lt;condition&gt; is TRUE our program will run Code block A, Code block B and finally Code block C. Below we present two examples where two if statements are used. In the first example, we use an if statement to compute the absolute value of a variable called x: x &lt;- 4 if (x &lt; 0){ x &lt;- -x } x ## [1] 4 Now we change x to a negative value: x &lt;- -4 if (x &lt; 0){ x &lt;- -x } x ## [1] 4 In the second example, we use an if statement to assess if x is an even number and, if this is the case, we print a simple message. if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) } ## [1] &quot;4 is an even number&quot; x &lt;- 3 if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) } 5.2.2.2 if/else Statements Often when we write a program we want to tell R what to do when our condition is TRUE and also what to do when it is FALSE. Of course, we could do something like: if (condition){ plan A } if (!condition){ plan B } However, the above syntax is somewhat clumsy and one generally would prefer to use an if/else statement. In plain English it would correspond to something like, “If this is true, then do plan A otherwise do plan B”. In R we would write: if (condition){ plan A }else{ plan B } Similarly to an if statement, we can represent an if/else statement using the diagram below: Therefore, when &lt;condition&gt; is TRUE our program will run Code block A, Code block B and then Code block D while when &lt;condition&gt; is FALSE it will run Code block A, Code block B and finally Code block D. Using this new tool we can revisit our previous example on even numbers to include a custom message in the case of an odd number. This can be done as follows: x &lt;- 2 if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) }else{ print(paste(x, &quot;is an odd number&quot;)) } ## [1] &quot;2 is an even number&quot; x &lt;- 3 if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) }else{ print(paste(x, &quot;is an odd number&quot;)) } ## [1] &quot;3 is an odd number&quot; 5.2.2.3 if/elseif/else Statements We can also control the flow of statements with multiple if/else statements, depending on the number of cases we consider. Typically, the more cases we have, the more else if statements. An example visualization is provided below. 5.2.2.4 switch Statement Above we mentioned that if/elseif/else statement allowed us to choose between TRUE and FALSE when there are two options. With the above idea, when there are more than two options, we can simply use nested if else statement. What about when we have say 20 options to choose from? In this case, if we still sticks on using nested if else statement, the programming logic will be very difficult to understand. Switch statement option in R programming can help us handle this type of problems more effectively. Before we put switch statement into case study, let’s first start to understand the basic switch statement syntax in R. switch (Expression, &quot;Option 1&quot; = Execute this statement when the expression result matches Option 1, &quot;Option 2&quot; = Execute this statement when the expression result matches Option 2, &quot;Option 3&quot; = Execute this statement when the expression result matches Option 3, .... .... &quot;Option N&quot; = Execute this statement when the expression result matches Option N, Default Statements ) The expression value is the condition which R will evaluate. This should be either integer or character. When the expression value matches more than one option, the first matching statemnet will be returned. Besides the conditional statement, R also allows us to add the default statement, which will be returned when none of the listed options are matched. With the above syntax in mind, now let’s check out a simple case study with R switch statement. number1 = 20 number2 = 5 operator = readline(prompt=&quot;Please enter any ARITHMETIC OPERATOR: &quot;) ## Please enter any ARITHMETIC OPERATOR: switch(operator, &quot;+&quot; = print(paste(&quot;Addition of two numbers is: &quot;, number1 + number2)), &quot;-&quot; = print(paste(&quot;Subtraction of two numbers is: &quot;, number1 - number2)), &quot;*&quot; = print(paste(&quot;Multiplication of two numbers is: &quot;, number1 * number2)), &quot;/&quot; = print(paste(&quot;Division of two numbers is: &quot;, number1 / number2)) ) When running the above code in R, we can expect results like: In conclusion, we can visualize the R switch statement as follows: 5.2.2.5 for Loops Now let’s consider the following situation. print(1) print(2) print(3) print(4) print(5) print(6) This seems feasible when we only need to print out the numbers from 1 to 6. What if we want to print out the numbers from 1 to 100? It is such a clumsy and tedious approach if we keep repeating print() line by line to do so. For loops in R help us solve this type of problems much more effectively in only a couple lines of codes. It allows us to repeat the same part of code, or say a sequence of same instructions, under certain conditions without explicitly writing out the code everytime. For example, to do exactly the same as the above example with for loops, all we need is: for (number in 1:6){ print(number) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 To interpret the above for loops in plain English, we can read it as “When the number is in the sequence {1,2,3,4,5,6}, we will print this number until we exhaust all numbers in the sequence”. As we can see obviously, this approach simplifies our code so much more as we only need to write the code chunk (print() in this case) once, not six times, not to mention when we want to print out all the numbers from 1 to 100 compared to repeating print() line by line for 100 times. The basic syntax of for loops in R is as follows: for (some specified sequence to loop over){ execute this statement when we still haven not reached the last item in the sequence } Next also helps when you want to skip for some cases in which you don’t want the statement to be executed. To see how next works together with for loops in R, let’s consider the following more mathematical example when you want to print out all the odd numbers between 1 to 10. for (i in 1:10) { if (!i %% 2){ next } print(i) } ## [1] 1 ## [1] 3 ## [1] 5 ## [1] 7 ## [1] 9 From the results, we notice that R automatically skip to run print(i) when !i %%2 is TRUE. To interpret the above in plain English, we can read it as “if the number i cannot be divided by 2, we skip the below and consider the NEXT number in the sequence”. In this case, we can still use for loops when we have some exceptional cases. In conclusion, we can visualize the R for loops as follows: Up till now, we can see that for loops can simplify our work a lot when we need to execute a sequence of same instructions for multiple times. However, there are still disadvantages to use for loops in R. We may hardly notice now with only a few simple iterations to run. But indeed, R can be very slow when running iteration, especially when we need to do a lot of big iterations with big data. Sometimes we may prefer to avoid using for loops in R by using other approaches since R supports vectorization, which will allow for much faster calculations. For example, solutions that make use of loops are less efficient than vectorized solutions that make use of apply functions, such as lapply and sapply. It’s often better to use the latter. Apply methods are often used to make operations on some structured data. For example, let’s simulate a matrix of some random samples. (exp_mat = matrix(rnorm(60),ncol = 3)) ## [,1] [,2] [,3] ## [1,] 1.2390050 0.78187385 1.0308199 ## [2,] -0.2597285 -0.92456627 -0.0332635 ## [3,] -0.3019634 0.66263908 -0.2347382 ## [4,] 1.2204948 1.19841118 0.3213612 ## [5,] 1.1481344 -0.96532695 -0.1221091 ## [6,] 0.2195048 0.06222611 -0.1336575 ## [7,] -1.1471578 -2.02224114 0.7074466 ## [8,] -0.0662807 -0.22149734 1.4681526 ## [9,] -0.6879061 -0.25742400 -0.5986041 ## [10,] -0.4550665 -1.53343531 -0.3902183 ## [11,] 0.6040878 0.69960924 -1.2632732 ## [12,] 0.2456773 1.39668445 -1.0068657 ## [13,] 2.0770018 0.79997177 -1.3888033 ## [14,] -0.9054415 0.76093351 0.8443096 ## [15,] -1.0622024 -1.57126093 -0.1847638 ## [16,] -1.4745098 0.44841908 -0.5928991 ## [17,] -0.7447718 0.68938380 1.5996440 ## [18,] -0.7552902 0.62665818 -0.7131084 ## [19,] -0.8978448 1.45091002 -1.8649359 ## [20,] -1.0892389 0.27187831 1.0290167 To get the mean of each column, we can calculate each column mean separately or use a for loop. # Observe what this does mean(exp_mat) ## [1] -0.03776899 # Calculate separately mean(exp_mat[,1]) ## [1] -0.1546748 mean(exp_mat[,2]) ## [1] 0.1176923 mean(exp_mat[,3]) ## [1] -0.07632448 # Using a for loop for(i in 1:3){ print(mean(exp_mat[,i])) } ## [1] -0.1546748 ## [1] 0.1176923 ## [1] -0.07632448 However, using apply, we can do this in a very simple manner. apply(exp_mat, 2, mean) ## [1] -0.15467483 0.11769233 -0.07632448 # The 2 indicates operations on columns and not rows We will see how these approaches can help accelerate our work later. 5.2.2.6 while Statements As an alternative of for loops, while statement in R is another approach that can help us repeat the code chunk only when specific conditions are satisfied. For example, we can use while statement to do exactly the same as above to print out all numbers from 1 to 6 as followings: i = 1 while (i &lt;= 6){ print(i) i = i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 The above code can be interprented in plain English as: “Let’s start with number 1. When the number i is still smaller than or equal to 6, we print it out. Then we consider the next integer of it and stop when we finish all the numbers smaller than or equal to 6.” As we can see, while statement is used to iterate until a specific condition is met. To make use of while statement in R, we introduce the basic syntax of it as following: while (some specified condition) { statement to execute when the above condition is satisfied } Here we evaluate the condition and if it is TRUE, then we execute the statement inside the code chunk. Once we finish running the statement, we evaluate the condition again and exit the loops when the condition is evaluated as FALSE. In conclusion, we can visualize how the while statement works in R as following: 5.2.3 Iterative Control Statements Iterative control statements are extremly usefull R’s method for repeating a task multiple times. For example, pretend we are trying to build a program that solves a simple maze like the one below. It would be pretty easy to simply draw out the possible solutions with the naked eye. However, if you were actually inside the maze, you would need to narrow your perspective and think of a strategy, like marking paths you have already visited. Suppose that we have strategy in mind to solve this problem. For example, we could consider the following approach at any given point in time: if there is space in front of you, go forward else, if there is space on your right, turn right else, if there is space on your left, turn left else, [all three sides (forward, left, right) are closed] turn around This strategy could easily be programmed using the methods discussed in Section 5.2 but to actually program it you would need to repeat this strategy until you escaped the maze. Your strategy could for example be written as: repeat (until &quot;you are free&quot;){ if (&quot;space in front of you&quot;){ go forward }else if (&quot;space on your right&quot;){ turn right }else if (&quot;space on your left&quot;){ turn left }else{ turn around } } Try to apply algorithm to the maze presented above. Could you escape? Though it might take some time and probably is not the fastest strategy one can show that this method can solve any maze (assuming of course that a solution exists). In this section we discuss how to actually program the “repeat (until &quot;you are free&quot;)” part of our algorithm. 5.2.3.1 for "]
=======
["control.html", "Chapter 5 Control Structures 5.1 Introduction 5.2 Selection control statements", " Chapter 5 Control Structures 5.1 Introduction When you’re building a larger or more complex program than the examples we considered previously, we need to use various control structures to control the “flow” of our actions. Essentially, a control structure is a “block” of code that analyzes variables and chooses a direction in which to go based on given parameters. These pieces of code represent the most basic decision-making processes in computing. There exist essentially two kinds of control structures. The first one allows to determine whether a given condition is satisfied and select an appropriate response. A simple analogy to our day-to-day life would be “if it’s raining outside, then take an umbrella” (we will come back to this example in the next section). The second kind of control structure allows to repeat of a block of code multiple times. For example, such an approach can be used to convert a color image to a gray-scale by applying the same operation(s) (i.e. same code) to each pixel of the image. In this chapter, we will first discuss the two kinds of control structures previously mentioned and then present various examples to help build our intuition. 5.2 Selection control statements Suppose that we are interested in creating a simple code to check if it rained over the last hour and, if this is the case, lead us to decide whether we should take an umbrella today. To write such a code we essentially need three things: Find out how much it rained in the last hour at our location. Such information is now easily accessible through various websites and we can for example used the R package rwunderground to access this information. Note that you will need to create an account and request an API key before being able to use it (see package documentation for more details). Then, the amount of precipitation (in inches) in the last hour can be retrieved using the code below: library(rwunderground) (rain &lt;- conditions(set_location(zip_code = &quot;16802&quot;), message = FALSE)$precip_1hr) ## [1] 0 Construct a logical (or Boolean) variable created from the variable rain to assess whether or not an umbrella is needed. For example, we can say that if we see signs of rain in the last hour, then we should take an umbrella. This can be done using the code below and in Section @ref(logical_operators) we will discuss how to construct logical variables in more detail. (umbrella &lt;- rain &gt; 0) ## [1] FALSE Finally, we need to select operators based on the logical variables constructed in the previous step to bring everything together. For example, we could use the if/else statement presented below. This simple code will print “You should probably take an umbrella” if the logical variable umbrella is TRUE and print “An umbrella is probably not necessary”, otherwise. if (umbrella){ print(&quot;You should probably take an umbrella&quot;) }else{ print(&quot;An umbrella is probably not necessary&quot;) } ## [1] &quot;An umbrella is probably not necessary&quot; 5.2.1 Logical Operators Logical operators are very commonly used in programming to create (or return) logical (boolean) variables. In general, logical operations take place by comparing one or more variables following specific rules. The table below summarizes the commonly used logical operators: Command Description Example Result x &gt; y x greater than y 4 &gt; 3 TRUE x &gt;= y x greater or equals to y 1 &gt;= 1 TRUE x &lt; y x less than y c(12 &lt; 20, 1 &lt; 1) TRUE, FALSE x &lt;= y x less than or equals to y 12 &lt;= 1 FALSE x == y x equal to y c(2 == 2, 1 == 2) TRUE, FALSE x != y x not equal to y c(2 != 2, F != T) FALSE, TRUE !x Not x c(!(2 &gt; 1), !FALSE) FALSE, TRUE x ||y x or y (not vectorized) (1 &gt; 1) || (2 &lt; 3) TRUE x |y x or y (vectorized) c(1 &gt; 1, F) || c(T, 2 &lt; 3) TRUE x &amp;&amp; y x and y (not vectorized) TRUE &amp;&amp; TRUE TRUE x &amp; y x and y (vectorized) c(TRUE, T) &amp; c(TRUE, F) TRUE, FALSE xor(x,y) test if only one is TRUE xor(TRUE, TRUE) FALSE all(x) test if all are TRUE all(c(T, F, F)) FALSE any(x) test if one or more is TRUE any(c(T, F, F)) TRUE There is a subtle difference between ||and | (or &amp;&amp; and &amp;). Indeed, when using x &amp;&amp; y or x || y it implicitly assumes that x and yare of length 1 and when these are applied to vectors only the first elements of each vector will be considered. For example, c(TRUE,FALSE) || c(FALSE, FALSE) is equivalent to TRUE || FALSE and will only return TRUE. On the other hand, &amp; and | can be applied to vectors and c(TRUE,FALSE) || c(FALSE, FALSE) is equivalent to c(TRUE || FALSE, FALSE || FALSE) and will return TRUE FALSE. It is also worth mentioning that TRUE | c(FALSE, FALSE) is equivalent to c(TRUE || FALSE, TRUE || FALSE) (i.e. the TRUE is used twice) and will return TRUE TRUE. These differences are a common source of bugs. When using &amp; or | to create/return logical variables we have to be aware of something called short-circuit evaluation which can create bugs that may be difficult to find. Indeed, suppose that we interested in using an expression such as x &amp; y and that if the variable x is FALSE then y will not be evaluated. The idea behind this evaluation is that, regardless of the value of y, the expression x &amp; y should be TRUE. However, this implicitly assumes that y does not contain any mistakes and if this were indeed to be the case, this could create bugs that would be hard to find. For example, consider the expression y = x &amp;&amp; 2 == NULL, then if x is FALSE y will be FALSE while if x is TRUE y will be NA, which obviously is likely to be problematic. Similarly, when considering an expression such as x | y, the variable y will only be evaluated if x is FALSE. 5.2.2 Selection Operators Selection operators govern the flow of code. We can observe if/else statements everywhere, no matter what language. 5.2.2.1 if Statements The most basic selection operator is called an if statement. Essentially, an if statement tells R to do a certain task for a certain case. In plain English it would correspond to something like, “If this is true, do that” or as in our motivating example “If it rains take an umbrella”. In R, you would say: if (&lt;this is TRUE&gt;){ &lt;do that&gt; } or if (&lt;it rains&gt;){ &lt;take an umbrella&gt; } In general, we can represent an if statement using the following diagram: The &lt;conditon&gt; denotes a logical variable that is used determine if the code inside of { } will be evaluated. For example, if &lt;condition&gt; is FALSE then our program will run Code block A and then Code block C. On the other hand, if &lt;condition&gt; is TRUE our program will run Code block A, Code block B and finally Code block C. Below we present two examples where two if statements are used. In the first example, we use an if statement to compute the absolute value of a variable called x: x &lt;- 4 if (x &lt; 0){ x &lt;- -x } x ## [1] 4 Now we change x to a negative value: x &lt;- -4 if (x &lt; 0){ x &lt;- -x } x ## [1] 4 In the second example, we use an if statement to assess if x is an even number and, if this is the case, we print a simple message. if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) } ## [1] &quot;4 is an even number&quot; x &lt;- 3 if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) } 5.2.2.2 if/else Statements Often when we write a program we want to tell R what to do when our condition is TRUE and also what to do when it is FALSE. Of course, we could do something like: if (condition){ plan A } if (!condition){ plan B } However, the above syntax is somewhat clumsy and one generally would prefer to use an if/else statement. In plain English it would correspond to something like, “If this is true, then do plan A otherwise do plan B”. In R we would write: if (condition){ plan A }else{ plan B } Similarly to an if statement, we can represent an if/else statement using the diagram below: Therefore, when &lt;condition&gt; is TRUE our program will run Code block A, Code block B and then Code block D while when &lt;condition&gt; is FALSE it will run Code block A, Code block B and finally Code block D. Using this new tool we can revisit our previous example on even numbers to include a custom message in the case of an odd number. This can be done as follows: x &lt;- 2 if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) }else{ print(paste(x, &quot;is an odd number&quot;)) } ## [1] &quot;2 is an even number&quot; x &lt;- 3 if (x %% 2 == 0){ print(paste(x, &quot;is an even number&quot;)) }else{ print(paste(x, &quot;is an odd number&quot;)) } ## [1] &quot;3 is an odd number&quot; 5.2.2.3 if/elseif/else Statements We can also control the flow of statements with multiple if/else statements, depending on the number of cases we consider. Typically, the more cases we have, the more else if statements. An example visualization is provided below. 5.2.2.4 switch Statement Above we mentioned that if/elseif/else statement allowed us to choose between TRUE and FALSE when there are two options. With the above idea, when there are more than two options, we can simply use nested if else statement. What about when we have say 20 options to choose from? In this case, if we still sticks on using nested if else statement, the programming logic will be very difficult to understand. Switch statement option in R programming can help us handle this type of problems more effectively. Before we put switch statement into case study, let’s first start to understand the basic switch statement syntax in R. switch (Expression, &quot;Option 1&quot; = Execute this statement when the expression result matches Option 1, &quot;Option 2&quot; = Execute this statement when the expression result matches Option 2, &quot;Option 3&quot; = Execute this statement when the expression result matches Option 3, .... .... &quot;Option N&quot; = Execute this statement when the expression result matches Option N, Default Statements ) The expression value is the condition which R will evaluate. This should be either integer or character. When the expression value matches more than one option, the first matching statemnet will be returned. Besides the conditional statement, R also allows us to add the default statement, which will be returned when none of the listed options are matched. With the above syntax in mind, now let’s check out a simple case study with R switch statement. number1 = 20 number2 = 5 operator = readline(prompt=&quot;Please enter any ARITHMETIC OPERATOR: &quot;) ## Please enter any ARITHMETIC OPERATOR: switch(operator, &quot;+&quot; = print(paste(&quot;Addition of two numbers is: &quot;, number1 + number2)), &quot;-&quot; = print(paste(&quot;Subtraction of two numbers is: &quot;, number1 - number2)), &quot;*&quot; = print(paste(&quot;Multiplication of two numbers is: &quot;, number1 * number2)), &quot;/&quot; = print(paste(&quot;Division of two numbers is: &quot;, number1 / number2)) ) When running the above code in R, we can expect results like: In conclusion, we can visualize the R switch statement as follows: 5.2.2.5 for Loops Now let’s consider the following situation. print(1) print(2) print(3) print(4) print(5) print(6) This seems feasible when we only need to print out the numbers from 1 to 6. What if we want to print out the numbers from 1 to 100? It is such a clumsy and tedious approach if we keep repeating print() line by line to do so. For loops in R help us solve this type of problems much more effectively in only a couple lines of codes. It allows us to repeat the same part of code, or say a sequence of same instructions, under certain conditions without explicitly writing out the code everytime. For example, to do exactly the same as the above example with for loops, all we need is: for (number in 1:6){ print(number) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 To interpret the above for loops in plain English, we can read it as “When the number is in the sequence {1,2,3,4,5,6}, we will print this number until we exhaust all numbers in the sequence”. As we can see obviously, this approach simplifies our code so much more as we only need to write the code chunk (print() in this case) once, not six times, not to mention when we want to print out all the numbers from 1 to 100 compared to repeating print() line by line for 100 times. The basic syntax of for loops in R is as follows: for (some specified sequence to loop over){ execute this statement when we still haven not reached the last item in the sequence } Next also helps when you want to skip for some cases in which you don’t want the statement to be executed. To see how next works together with for loops in R, let’s consider the following more mathematical example when you want to print out all the odd numbers between 1 to 10. for (i in 1:10) { if (!i %% 2){ next } print(i) } ## [1] 1 ## [1] 3 ## [1] 5 ## [1] 7 ## [1] 9 From the results, we notice that R automatically skip to run print(i) when !i %%2 is TRUE. To interpret the above in plain English, we can read it as “if the number i cannot be divided by 2, we skip the below and consider the NEXT number in the sequence”. In this case, we can still use for loops when we have some exceptional cases. In conclusion, we can visualize the R for loops as follows: Up till now, we can see that for loops can simplify our work a lot when we need to execute a sequence of same instructions for multiple times. However, there are still disadvantages to use for loops in R. We may hardly notice now with only a few simple iterations to run. But indeed, R can be very slow when running iteration, especially when we need to do a lot of big iterations with big data. Sometimes we may prefer to avoid using for loops in R by using other approaches since R supports vectorization, which will allow for much faster calculations. For example, solutions that make use of loops are less efficient than vectorized solutions that make use of apply functions, such as lapply and sapply. It’s often better to use the latter. Apply methods are often used to make operations on some structured data. For example, let’s simulate a matrix of some random samples. (exp_mat = matrix(rnorm(60),ncol = 3)) ## [,1] [,2] [,3] ## [1,] 0.50674581 -0.82145941 0.81857841 ## [2,] -2.16231406 0.33445132 1.53780069 ## [3,] -1.38535605 -1.41653796 0.39514148 ## [4,] -0.79520671 -0.04352432 0.02859844 ## [5,] 0.74517553 -0.64172368 0.19991001 ## [6,] -0.24271185 1.58691400 -0.68547649 ## [7,] -0.79201879 -0.45511926 1.47307560 ## [8,] -0.40639941 -0.41635995 -1.01914711 ## [9,] 0.10364364 1.80132947 -1.28840678 ## [10,] 1.07829694 -1.46880702 -0.69738064 ## [11,] 0.51623362 -1.33123408 -0.87660626 ## [12,] 0.84720593 1.61116401 -0.57109845 ## [13,] -1.24413892 -0.67379274 0.56210416 ## [14,] -0.31501372 0.53842463 2.05451672 ## [15,] -0.47599519 0.99405908 -2.36904087 ## [16,] 0.84100428 -0.35173638 -1.70401065 ## [17,] -0.44565808 1.05358066 -1.32822464 ## [18,] -1.85394712 0.50586034 -1.53433216 ## [19,] 0.49410559 0.34141597 1.90242895 ## [20,] 0.08091881 -0.32868054 -0.07352967 To get the mean of each column, we can calculate each column mean separately or use a for loop. # Observe what this does mean(exp_mat) ## [1] -0.1210384 # Calculate separately mean(exp_mat[,1]) ## [1] -0.2452715 mean(exp_mat[,2]) ## [1] 0.04091121 mean(exp_mat[,3]) ## [1] -0.158755 # Using a for loop for(i in 1:3){ print(mean(exp_mat[,i])) } ## [1] -0.2452715 ## [1] 0.04091121 ## [1] -0.158755 &lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream However, using apply, we can do this in a very simple manner. apply(exp_mat, 2, mean) ## [1] -0.24527149 0.04091121 -0.15875496 # The 2 indicates operations on columns and not rows We will see how these approaches can help accelerate our work later. 5.2.2.6 while Statements As an alternative of for loops, while statement in R is another approach that can help us repeat the code chunk only when specific conditions are satisfied. For example, we can use while statement to do exactly the same as above to print out all numbers from 1 to 6 as followings: i = 1 while (i &lt;= 6){ print(i) i = i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 The above code can be interprented in plain English as: “Let’s start with number 1. When the number i is still smaller than or equal to 6, we print it out. Then we consider the next integer of it and stop when we finish all the numbers smaller than or equal to 6.” As we can see, while statement is used to iterate until a specific condition is met. To make use of while statement in R, we introduce the basic syntax of it as following: while (some specified condition) { statement to execute when the above condition is satisfied } Here we evaluate the condition and if it is TRUE, then we execute the statement inside the code chunk. Once we finish running the statement, we evaluate the condition again and exit the loops when the condition is evaluated as FALSE. In conclusion, we can visualize how the while statement works in R as following: 5.2.3 Iterative Control Statements Iterative control statements are extremly usefull R’s method for repeating a task multiple times. For example, pretend we are trying to build a program that solves a simple maze like the one below. It would be pretty easy to simply draw out the possible solutions with the naked eye. However, if you were actually inside the maze, you would need to narrow your perspective and think of a strategy, like marking paths you have already visited. Suppose that we have strategy in mind to solve this problem. For example, we could consider the following approach at any given point in time: if there is space in front of you, go forward else, if there is space on your right, turn right else, if there is space on your left, turn left else, [all three sides (forward, left, right) are closed] turn around This strategy could easily be programmed using the methods discussed in Section 5.2 but to actually program it you would need to repeat this strategy until you escaped the maze. Your strategy could for example be written as: repeat (until &quot;you are free&quot;){ if (&quot;space in front of you&quot;){ go forward }else if (&quot;space on your right&quot;){ turn right }else if (&quot;space on your left&quot;){ turn left }else{ turn around } } Try to apply algorithm to the maze presented above. Could you escape? Though it might take some time and probably is not the fastest strategy one can show that this method can solve any maze (assuming of course that a solution exists). In this section we discuss how to actually program the “repeat (until &quot;you are free&quot;)” part of our algorithm. 5.2.3.1 for "]
>>>>>>> origin/master
]
