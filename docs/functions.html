<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>An Introduction to Statistical Programming Methods with R</title>
  <meta name="description" content="This book is under construction and serves as a reference for students or other interested readers who intend to learn the basics of statistical programming using the R language. The book will provide the reader with notions of data management, manipulation and analysis as well as of reproducible research, result-sharing and version control.">
  <meta name="generator" content="bookdown 0.4.1 and GitBook 2.6.7">

  <meta property="og:title" content="An Introduction to Statistical Programming Methods with R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This book is under construction and serves as a reference for students or other interested readers who intend to learn the basics of statistical programming using the R language. The book will provide the reader with notions of data management, manipulation and analysis as well as of reproducible research, result-sharing and version control." />
  <meta name="github-repo" content="smac-group/ds" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="An Introduction to Statistical Programming Methods with R" />
  
  <meta name="twitter:description" content="This book is under construction and serves as a reference for students or other interested readers who intend to learn the basics of statistical programming using the R language. The book will provide the reader with notions of data management, manipulation and analysis as well as of reproducible research, result-sharing and version control." />
  

<meta name="author" content="Matthew Beckman, Stéphane Guerrier, Justin Lee &amp; Roberto Molinari">


<meta name="date" content="2017-10-11">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="control.html">
<link rel="next" href="placeholder.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Statistical Programming Methods</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="part"><span><b>I Foundation</b></span></li>
<li class="chapter" data-level="2" data-path="rmarkdown.html"><a href="rmarkdown.html"><i class="fa fa-check"></i><b>2</b> RMarkdown</a></li>
<li class="chapter" data-level="3" data-path="github.html"><a href="github.html"><i class="fa fa-check"></i><b>3</b> GitHub</a></li>
<li class="part"><span><b>II Introduction to R</b></span></li>
<li class="chapter" data-level="4" data-path="data.html"><a href="data.html"><i class="fa fa-check"></i><b>4</b> Data Structures</a></li>
<li class="chapter" data-level="5" data-path="control.html"><a href="control.html"><i class="fa fa-check"></i><b>5</b> Control Structures</a></li>
<li class="chapter" data-level="6" data-path="functions.html"><a href="functions.html"><i class="fa fa-check"></i><b>6</b> Functions</a><ul>
<li class="chapter" data-level="6.0.1" data-path="functions.html"><a href="functions.html#example-the-hubble-constant"><i class="fa fa-check"></i><b>6.0.1</b> Example: The Hubble Constant</a></li>
<li class="chapter" data-level="6.1" data-path="functions.html"><a href="functions.html#r-functions"><i class="fa fa-check"></i><b>6.1</b> R functions</a><ul>
<li class="chapter" data-level="6.1.1" data-path="functions.html"><a href="functions.html#the-algebra-behind-least-squares-inference"><i class="fa fa-check"></i><b>6.1.1</b> The Algebra behind Least-Squares Inference</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="functions.html"><a href="functions.html#creating-functions-in-r"><i class="fa fa-check"></i><b>6.2</b> Creating functions in R</a><ul>
<li class="chapter" data-level="6.2.1" data-path="functions.html"><a href="functions.html#function-arguments"><i class="fa fa-check"></i><b>6.2.1</b> Function arguments</a></li>
<li class="chapter" data-level="6.2.2" data-path="functions.html"><a href="functions.html#function-body"><i class="fa fa-check"></i><b>6.2.2</b> Function body</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="functions.html"><a href="functions.html#function-environment"><i class="fa fa-check"></i><b>6.3</b> Function environment</a></li>
<li class="chapter" data-level="6.4" data-path="functions.html"><a href="functions.html#example-continued-function-comparison-and-hypothesis-testing"><i class="fa fa-check"></i><b>6.4</b> Example (continued): function comparison and hypothesis testing</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="placeholder.html"><a href="placeholder.html"><i class="fa fa-check"></i><b>7</b> Placeholder</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">An Introduction to Statistical Programming Methods with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="functions" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Functions</h1>
<p>This chapter aims at highlighting the main advantages, characteristics, arguments and structure of functions in R. As you already know, a function is a collection of logically connected commands and operations that allow the user to input some arguments and obtain a desired output (based on the given arguments) without having to rewrite the mentioned code each time that specific output is needed. Indeed, a common task in statistical research consists in running some simulation studies which give support (or not) to the use of a certain method of inference. In this case, it’s not efficient to rewrite the code each time it is needed within a simulation study because it would lead to lengthy code and increased risk of miss-coding.</p>
<p>Considering this, in the previous chapter we discussed matrix algebra in R. Using these notions, in this chapter we will implement a function that allows us to perform least-squares regression and inference. Indeed, it may be interesting to understand the behavior of this estimator in different simulation settings and it would not be practical to rewrite the series of commands to obtain the least-squares estimator in each setting. For this reason, a function that implements this estimator would be more appropriate and, in fact, this function already exists in the base R functions and is called <code>lm()</code>. However, in this chapter we will build our own least-squares regression function and compare its results with those of <code>lm()</code> to check if they’re the same. To do so, we will consider a dataset in which linear regression is used to study the age of the universe.</p>
<div id="example-the-hubble-constant" class="section level3">
<h3><span class="header-section-number">6.0.1</span> Example: The Hubble Constant</h3>
<p>The example dataset we will study is taken from <span class="citation">Wood (<a href="#ref-wood2017generalized">2017</a>)</span> which discusses data collected from the Hubble Space Telescope key project containing information on the velocity and relative distance of 24 galaxies. This information has been used to compute the “Hubble constant” which is a fixed parameter that links velocity and distance of celestial bodies through which it is possible to compute the age of the universe based on the “Big Bang” theory. The link is given by this simple linear relationship</p>
<span class="math display">\[\begin{equation*}
  y = \beta x ,
\end{equation*}\]</span>
<p>where <span class="math inline">\(y\)</span> represents the velocity while <span class="math inline">\(x\)</span> is the distance between galaxies. Once the Hubble constant is known, its inverse (i.e. <span class="math inline">\(\beta^{-1}\)</span>) gives the age of the universe based on the big bang theory.</p>
<p>Therefore let us use the abovementioned dataset to estimate Hubble’s constant to then get an estimate of the age of the universe. This dataset can be found in the <code>gamair</code> package under the name <code>hubble</code> and when plotting the two variables of interest in a scatterplot there appears to be a positive linear relationship between the two variables.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load gamair library and retrieve Hubble dataset</span>
<span class="kw">library</span>(gamair)
<span class="kw">data</span>(hubble)

<span class="co"># Plot data</span>
<span class="kw">plot</span>(<span class="dt">y =</span> hubble$y, <span class="dt">x =</span> hubble$x, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>, <span class="dt">main=</span><span class="st">&quot;Distance vs. Velocity&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Velocity (in km/s)&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;Distance (in Megaparsecs)&quot;</span>)</code></pre></div>
<p><img src="ds_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<p>In this chapter we will therefore build a function to obtain an estimate of <span class="math inline">\(\beta\)</span> and, consequently, an estimate of the age of the universe based on the big bang theory.</p>
</div>
<div id="r-functions" class="section level2">
<h2><span class="header-section-number">6.1</span> R functions</h2>
<p>In order to build our function, the next sections will present the main features of functions in R by studying their main components. The following annotated example gives a brief overview of a simple function that takes two values and sums them:</p>
<center>
<img src="images/function_scheme.png" alt="Function Structure" />
</center>
<p>As can be noticed, we first define the name we want to give to the function.</p>

<div class="rmdwarning">
It is important to make sure that the function name is specific and does not correspond to other functions that may need to be used within your work session. If two functions have the same name, just as with other R objects, the function that will be used is the last one that has been defined within the R working session.
</div>
<p></p>
<p>Once we have defined the name, we then attribute a function to this name by using the <code>function</code> syntax to which we assign some parameters (or attributes). The latter are the values or data that the user will input in order for the function to deliver the desired output. The latter is subsequently obtained through the code constituting the <em>body</em> of the function. Once the code has made the necessary computations, the function needs to know which results need to be given as an output. This can be done, for example, using the <code>return</code> syntax.</p>
<p>Having seen the general structure of an R function, let us go more into detail by analysing the three main components to R functions:</p>
<ul>
<li><em>body</em>: the code lines containing the commands and operations which deliver the desired output;</li>
<li><em>arguments</em>: the inputs the user gives to the function which will determine the value or type of output of a function;</li>
<li><em>environment</em>: every R function is built within an enviroment of reference from which to source possible input values and/or other functions necessary for it to work.</li>
</ul>
<p>While the first component is the collection of commands that we saw in the previous chapters, we will focus more on the last two components by building our own function for least-squares estimation and inference. Before we implement the function, let us review the algebra behind least-squares regression which will also be helpful in revising matrix algebra in R that was seen in the previous chapter.</p>
<div id="the-algebra-behind-least-squares-inference" class="section level3">
<h3><span class="header-section-number">6.1.1</span> The Algebra behind Least-Squares Inference</h3>
<p>In the framework of linear regression the goal is to explain an <span class="math inline">\(n \times 1\)</span> vector of observations <span class="math inline">\(\mathbf{y}\)</span> (representing the response variable) through a linear combination of <span class="math inline">\(p\)</span> explanatory variables (or predictors or covariates) that are stored in an <span class="math inline">\(n \times p\)</span> matrix <span class="math inline">\(\mathbf{X}\)</span>. More specifically, the framework is the following: <span class="math display">\[\mathbf{y} = \mathbf{X}^T\boldsymbol{\beta} + \mathbf{\epsilon}\]</span>, where <span class="math inline">\(\boldsymbol{\beta}\)</span> is the <span class="math inline">\(p \times 1\)</span> parameter vector of interest that links the covariates with the response variable while <span class="math inline">\(\mathbf{\epsilon}\)</span> is the <span class="math inline">\(n \times 1\)</span> random error vector with null expectation and variance <span class="math inline">\(\sigma^2\)</span>.</p>
<p>When we collect data for the purpose of linear regression, the unknown terms in the above setting are the parameter vector <span class="math inline">\(\boldsymbol{\beta}\)</span> and the variance parameter <span class="math inline">\(\sigma^2\)</span>. In order to estimate <span class="math inline">\(\boldsymbol{\beta}\)</span>, assuming that the matrix <span class="math inline">\(\left(\mathbf{X}^T \mathbf{X}\right)^{-1}\)</span> exists, the least-squares estimator for it is given by:</p>
<span class="math display" id="eq:lsformula">\[\begin{equation}
  \hat{\boldsymbol{\beta}} = \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T \mathbf{y}
\tag{6.1}
\end{equation}\]</span>
<p>In the comment box below, we derive Eq. <a href="functions.html#eq:lsformula">(6.1)</a>. If you’re not familiar with such calculations we suggest you read some introduction to linear regression (see for example <span class="citation">Seber and Lee (<a href="#ref-seber2012linear">2012</a>)</span>).</p>

<div class="rmdtip">
<p>The least-square estimator <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is given by</p>
<span class="math display">\[\begin{equation*}
 \hat{\boldsymbol{\beta}} = \operatorname{argmin}_{\boldsymbol{\beta}} \; \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right) 
\end{equation*}\]</span>
<p>The first step of this derivation is to reexpress the term <span class="math inline">\(\left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right)\)</span> as follows:</p>
<span class="math display">\[\begin{equation*}
    \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right) =  \mathbf{y}^T\mathbf{y} +  \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X} \boldsymbol{\beta} - 2 \boldsymbol{\beta}^T \mathbf{X}^T \boldsymbol{y}.
\end{equation*}\]</span>
<p>In case you were suprizied by the term <span class="math inline">\(2 \boldsymbol{\beta}^T \mathbf{X}^T \boldsymbol{y}\)</span> remeber that a scalar can always be transposed without changing its value and therefore we have that $ ^T ^T  = ^T  $. Now, our next step is to the following derivative</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right).
\end{equation*}\]</span>
<p>To do this we should keep in mind the following results</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \boldsymbol{\beta}^T \mathbf{X}^T \boldsymbol{y} =   
   \boldsymbol{y}^T \mathbf{X},
\end{equation*}\]</span>
<p>and</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X} \boldsymbol{\beta} =  2 \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X}.
\end{equation*}\]</span>
<p>The proof of these two results can for example be found in Propositions 7 and 9 of <a href="http://www.atmos.washington.edu/~dennis/MatrixCalculus.pdf">Prof. Barnes’ notes</a>. Using these two results we obtain</p>
<span class="math display">\[\begin{equation*}
  \frac{\partial}{\partial \, \boldsymbol{\beta}} \; \left( \mathbf{y} - \mathbf{X}\boldsymbol{\beta} \right)^T \left( \mathbf{y} - \mathbf{X} \boldsymbol{\beta} \right) = 2 \boldsymbol{\beta}^T \mathbf{X}^T \mathbf{X} - 2 \boldsymbol{y}^T \mathbf{X}.
\end{equation*}\]</span>
<p>By solving for the first order condition (and under some technical assumptions not discussed here) we can redefine <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> through the follwing equation</p>
<span class="math display">\[\begin{equation*}
  \hat{\boldsymbol{\beta}}^T \mathbf{X}^T \mathbf{X} =  \boldsymbol{y}^T \mathbf{X},
\end{equation*}\]</span>
<p>which is equivalent to</p>
<span class="math display">\[\begin{equation*}
  \mathbf{X}^T \mathbf{X} \hat{\boldsymbol{\beta}} =   \mathbf{X}^T \boldsymbol{y}.
\end{equation*}\]</span>
<p>If <span class="math inline">\(\left(\mathbf{X}^T \mathbf{X}\right)^{-1}\)</span> exists, <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is therefore given by</p>
<span class="math display">\[\begin{equation*}
  \hat{\boldsymbol{\beta}} = \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T \mathbf{y},
\end{equation*}\]</span>
which verifies Eq. <a href="functions.html#eq:lsformula">(6.1)</a>.
</div>
<p></p>
<p>The variance of <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is given by</p>
<span class="math display" id="eq:lsvar">\[\begin{equation}
\text{Var} \left(\hat{\boldsymbol{\beta}} \right) = \sigma^2 \left(\mathbf{X}^T \mathbf{X}\right)^{-1},
\tag{6.2}
\end{equation}\]</span>
<p>the derivation of this result is explained in the comment box below.</p>

<div class="rmdtip">
<p>If we let <span class="math inline">\(\mathbf{A} = \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T\)</span>, then we have</p>
<span class="math display">\[\begin{equation*}
\begin{aligned}
  \text{Var} \left(\hat{\boldsymbol{\beta}} \right) &amp;= \text{Var} \left( \mathbf{A} \mathbf{y} \right) = \mathbf{A} \text{Var} \left(  \mathbf{y} \right) \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{A}^T \\
  &amp; = \sigma^2 \left(\mathbf{X}^T \mathbf{X}\right)^{-1} \mathbf{X}^T  \mathbf{X} \left(\mathbf{X}^T \mathbf{X}\right)^{-1} = \sigma^2 \left(\mathbf{X}^T \mathbf{X}\right)^{-1},
\end{aligned}
\end{equation*}\]</span>
<p>which verifies Eq. <a href="functions.html#eq:lsvar">(6.2)</a>. To understand the above derivation it may be useful to remind and point out a few things:</p>
<ul>
<li><span class="math inline">\(\text{Var} \left( \mathbf{A} \mathbf{y} \right) = \mathbf{A} \text{Var} \left( \mathbf{y} \right) \mathbf{A}^T\)</span> since <span class="math inline">\(\mathbf{A}\)</span> is not a random variable.</li>
<li><span class="math inline">\(\mathbf{A} \text{Var} \left( \mathbf{y} \right) \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{A}^T\)</span> since<span class="math inline">\(\text{Var} \left( \mathbf{y} \right) = \sigma^2 \mathbf{I}\)</span> and therefore we have <span class="math inline">\(\mathbf{A} \text{Var} \left( \mathbf{y} \right) \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{I} \mathbf{A}^T = \sigma^2 \mathbf{A} \mathbf{A}^T\)</span>.</li>
<li>The result <span class="math inline">\(\mathbf{A} \mathbf{A}^T = (\mathbf{X}^T \mathbf{X})^{-1}\)</span> is based on the fact that <span class="math inline">\((\mathbf{X}^T \mathbf{X})^{-1}\)</span> is symmetric but this is not necessarily intuitive. Indeed, this follows from the fact that any square and invertible matrix <span class="math inline">\(\mathbf{B}\)</span> is such that the inverse and transpose operator commute, meaning that <span class="math inline">\(( \mathbf{B}^T )^{-1} = ( \mathbf{B}^{-1} )^T\)</span>. Therefore since the matrix <span class="math inline">\(\mathbf{X}^T \mathbf{X}\)</span> is square and (by assumption) invertible we have <span class="math inline">\([(\mathbf{X}^T \mathbf{X})^{-1}]^T = [(\mathbf{X}^T \mathbf{X})^{T}]^{-1} = ( \mathbf{X}^T \mathbf{X})^{-1}\)</span>.
</div>
</li>
</ul>
<p>In general, the residual variance is unknown and needs to be estimated. A common and unbiased estimator of <span class="math inline">\(\sigma^2\)</span> is given by</p>
<span class="math display" id="eq:lssig2hat">\[\begin{equation}
  \hat{\sigma}^2 = \frac{1}{n - p}  \left( \mathbf{y} - \mathbf{X}\hat{\boldsymbol{\beta}} \right)^T \left( \mathbf{y} - \mathbf{X} \hat{\boldsymbol{\beta}}\right) 
  \tag{6.3}
\end{equation}\]</span>
<!-- DO YOU GUYS THINK WE SHOULD SHOW THE UNBIASEDNESS IN BOX HERE. THIS IS A LITTLE MORE ADVANCED AS WE NEED TO USE PROJECTION MATRICES AND THEIR PROPERTIES. LET ME KNOW. -->
<!-- ROB COMMENT: Maybe I'd ask them to show the unbiasdness as homework either theoretically or giving numerical support to the claim (e.g. the mean of different beta hats is close to the true beta) -->
<!-- JUSTIN COMMENT: I agree with Rob's suggestion :)  -->
<p>Let’s implement Eq. <a href="functions.html#eq:lsformula">(6.1)</a> to <a href="functions.html#eq:lssig2hat">(6.3)</a> and, later, compare the outcome with the <code>lm()</code> function for linear regression implemented in base R.</p>
</div>
</div>
<div id="creating-functions-in-r" class="section level2">
<h2><span class="header-section-number">6.2</span> Creating functions in R</h2>
<p>In the previous section we went over the algebra behind least-squares regression. Based on this, let us implement a function that delivers inference on the parameter vector <span class="math inline">\(\boldsymbol{\beta}\)</span> and therefore define the skeleton of this R function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm &lt;-<span class="st"> </span>function (...) {
  
  ...
  
}</code></pre></div>
<p>As you can see, we find a name for the function we want to build, which in this case is <code>my_lm</code>, and specify that we are going to attribute a <code>function</code> to this name. Following this assignment, we find a set of curved brackets <code>(...)</code> followed by a set of curly brackets <code>{...}</code> which should include the <em>arguments</em> and <em>body</em> of the function respectively. While the <em>body</em> of a function simply corresponds to all the command lines (and other functions) that are used to deliver an output, the next sections will tackle function arguments as well as other important aspects such as their environment and attributes.</p>
<div id="function-arguments" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Function arguments</h3>
<p>Before implementing a function, we first need to ask ourselves what is the basic information that we need in order to obtain the desired output. In the case of least-squares regression, as mentioned earlier, the only information that is essential to perform estimation and inference is the vector of observations <span class="math inline">\(\mathbf{y}\)</span> representing the response variable and the matrix of covariates <span class="math inline">\(\mathbf{X}\)</span>. These will therefore have to be the elements we need to provide to our function in order for it to deliver an estimate of <span class="math inline">\(\boldsymbol{\beta}\)</span> and, in R, we can provide the names we want for them (say <code>y</code> and <code>X</code> respectively):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm &lt;-<span class="st"> </span>function (y, X) {
  
  ...
  
}</code></pre></div>
<p>In the above syntax, we used so-called <em>positional matching</em> where arguments to the function must be entered in the same order as they are defined in the function itself. In our example, the response variable is given by <code>hubble$y</code> while the covariates (in this case only one covariate) is given by <code>hubble$x</code>. These arguments need to be entered in the correct order:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_lm</span>(hubble$y,hubble$x)</code></pre></div>
<p>since otherwise the function will either give the incorrect output or give errors since the format of the input could be incompatible with the body of the function. In general, it is therefore possible to use positional matching for the first and most important arguments of the function, but it is suggested to use names for the arguments. For our function, we could consequently define the arguments as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm &lt;-<span class="st"> </span>function (<span class="dt">y =</span> <span class="ot">NA</span>, <span class="dt">X =</span> <span class="ot">NA</span>) {
  
  ...
  
}</code></pre></div>
<p>You can notice that we assigned the value <code>NA</code> to both of these variables. This is their “default” value which, if not specified otherwise, is used as input for the function (which in this case would either give an error or output <code>NA</code>). For the purpose of illustration however, we will change the argument names as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm &lt;-<span class="st"> </span>function (response, covariates) {
  
  ...
  
}</code></pre></div>
<p>where <code>response</code> and <code>covariates</code> become the names of the variables that will be used within the body of the function for which we don’t specify default values.</p>

<div class="rmdnote">
According to the type of function, it is possible to give other default values that would deliver an output (see for example the values of the arguments <code>mean</code> and <code>sd</code> in the base function <code>rnorm()</code>).
</div>
<p></p>
<p>In this new setting, we would therefore use the function as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_lm</span>(<span class="dt">response =</span> hubble$y, <span class="dt">covariates =</span> hubble$x)</code></pre></div>
<p>Supposing that we leave the arguments of the functions defined as above, there are different ways to specify these arguments. When calling a function, R first matches the arguments through <em>perfect matching</em>, meaning that it searches for the arguments matching the exact name (in our case “response” and “covariates”). Failing to match the arguments by their exact name, R then searches for the arguments through <em>prefix matching</em>, meaning that it uses the first letters of the argument names to match them. For example, we could call the function in the following manner:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_lm</span>(<span class="dt">r =</span> hubble$y, <span class="dt">cova =</span> hubble$x)</code></pre></div>
<p>So, as long we correctly specify the beginning of the argument’s name and as long as it’s not ambigiuous (meaning that its name cannot be confused with that of another argument), then it is possible to provide only part of the argument’s name and R will recognise and correctly associate the provided value with the corresponding variable.</p>
<p>Finally, failing to match arguments in any of the above cases, R uses positional matching and therefore assigns values to the variables based on the order they have been entered when calling the function. We could therefore go back to using the function like we did at the start by specifying <code>my_lm(hubble$y, hubble$x)</code>.</p>

<div class="rmdnote">
It is possible to also specify arguments in terms of the default value of other arguments. For example, we could define a simple function <code>add(a, b)</code> (which produces the sum of the arguments <code>a</code> and <code>b</code>) and then specify the arguments as <code>a = 1, b = 2*a</code>. There are many other interesting ways of specifying argument values and they can be seen, for example, in <span class="citation">Wickham (<a href="#ref-wickham2014advanced">2014</a>)</span> .
</div>
<p></p>
<p>Additional arguments can be left to be specified by the user. This is the case, for example, when there is the possibility of specifying arguments for other functions that are used within the function itself. This can be done by using the argument <code>...</code> which can be added to any function and will match user-specified arguments that do not match the predefined ones in the function. An example of this type of argument is given by the base <code>plot()</code> function in R where the predefined arguments are <code>x</code> and <code>y</code> (representing the coordinates of the points in the plot) while other optional arguments, such as graphical parameters, can be added taking advantage of the <code>...</code> argument (e.g. the user could specify the argument <code>type = &quot;l&quot;</code> even though this is not included among the specified arguments of the function <code>plot()</code>). This argument is particularly useful when you want to obtain values for other function arguments but don’t want to specify their names in advance.</p>
</div>
<div id="function-body" class="section level3">
<h3><span class="header-section-number">6.2.2</span> Function body</h3>
<p>The body of a function is simply the set of instructions and (possible) other functions that use the arguments provided by the user and computes the desired output. In our case, we need to put into practice a series of tools we learned in the previous chapter (e.g. matrix operations) in order to implement Eq. <a href="functions.html#eq:lsformula">(6.1)</a> to <a href="functions.html#eq:lssig2hat">(6.3)</a> and, later, compare the outcome with the <code>lm()</code> function for linear regression implemented in base R.</p>
<p>Putting aside possible problems with the data that would require a more in-depth knowledge and discussion of linear regression theory, we can proceed to estimate the Hubble constant by using the velocity as the response variable <span class="math inline">\(y\)</span> and the distance as the explanatory variable <span class="math inline">\(x\)</span>. Let us therefore start by implementing Eq. <a href="functions.html#eq:lsformula">(6.1)</a> within our function in order to get an estimate of <span class="math inline">\(\beta\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates) {
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (1.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Return the estimated value of beta</span>
  beta.hat
  
}</code></pre></div>

<div class="rmdimportant">
Before discussing the body and output of this function, we can first underline an important aspect of programming. Indeed, we defined the number of covariates (and length of the vector <span class="math inline">\(\boldsymbol{\beta}\)</span>) as <code>p &lt;- dim(covariates)[2]</code> where the function <code>dim()</code> presupposes that the object <code>covariates</code> is a matrix. Nevertheless, in our case the object <code>covariates</code> would correspond to <code>hubble$x</code> which is a vector and therefore this operation would return <code>NULL</code> as an output. When programming it is therefore important to think ahead and understand if there are any particular cases where parts of the body of your function may not work.
</div>
<p></p>
<p>Taking into account the above note, it would be appropriate to make sure that the code in the body of the function works also in particular cases (e.g. the <code>covariates</code> object is a vector and not a matrix). In our case we therefore use the function <code>as.matrix()</code> which forces an object to be considered as a matrix in order for it to be used within matrix opeations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates) {
  
  <span class="co"># Make sure data formats are appropriate</span>
  response &lt;-<span class="st"> </span><span class="kw">as.vector</span>(response)
  covariates &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(covariates)
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (1.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Return the estimated value of beta</span>
  beta.hat
  
}</code></pre></div>

<div class="rmdtip">
Other checks can be introduced at the beginning of the function to make sure that the function is used correctly and obtain an appropriate output. In our case, for example, we could even introduce a check to understand if <code>response</code> and <code>covariates</code> have the same number of rows and interrupt the function execution and output an error message if this is not the case, making the user aware of this probem.
</div>
<p></p>
<p>As you may notice, using the matrix operators we obtain an object we decide to call <code>beta.hat</code> and, to tell the function to return this value, we simply specify it without any other commands after it has been computed. A more appropriate way of defining the outputs of a function would however be the <code>return()</code> function that avoids ambiguous outputs due to mistakes in coding or others within the function body. By using <code>return()</code> we make sure the desired outputs are given and it improves readability of the function for other users (see the next example further on).</p>
<p>With the <code>my_lm()</code> function we can now estimate the value for <span class="math inline">\(\beta\)</span> that we denote as <span class="math inline">\(\hat{\beta}\)</span>. However, we don’t have an estimate of its variance for which we would need to implement Equations <a href="functions.html#eq:lsvar">(6.2)</a> and <a href="functions.html#eq:lssig2hat">(6.3)</a>. We can therefore add these equations to the body of our <code>my_lm()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates) {
  
  <span class="co"># Make sure data formats are appropriate</span>
  response &lt;-<span class="st"> </span><span class="kw">as.vector</span>(response)
  covariates &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(covariates)
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (1.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Estimate of the residual variance (sigma2) from Eq. (1.3)</span>
  resid &lt;-<span class="st"> </span>response -<span class="st"> </span>covariates%*%<span class="kw">as.matrix</span>(beta.hat) <span class="co"># compute residuals</span>
  sigma2.hat &lt;-<span class="st"> </span>(<span class="dv">1</span>/df)*<span class="kw">t</span>(resid)%*%resid
  
  <span class="co"># Estimate of the variance of the estimated beta from Eq. (1.2)</span>
  var.beta &lt;-<span class="st"> </span>sigma2.hat*<span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)
  
  <span class="co"># Return all estimated values</span>
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">beta =</span> beta.hat, <span class="dt">sigma2 =</span> sigma2.hat, <span class="dt">variance_beta =</span> var.beta))
  
}</code></pre></div>
<p>There are a couple of things to underline in the above function. Firstly, when defining the <code>resid</code> object we also used <code>as.matrix()</code> for the object <code>beta.hat</code>: this is because it can happen (as in our example) that the dimension of <span class="math inline">\(\boldsymbol{\beta}\)</span> could be equal to one (i.e. a scalar) and the matrix multiplication would not work and output an error. By using the <code>as.matrix()</code> function, we ensure that this multiplication will work also when <span class="math inline">\(\boldsymbol{\beta}\)</span> is a scalar (i.e. when there is only one covariate). A second aspect to underline is the way in which we return multiple function outputs. Indeed, in our case we decide to return not only the estimate of <span class="math inline">\(\beta\)</span> but also the estimated residual variance as well as the variance of <span class="math inline">\(\hat{\beta}\)</span>. To do so, we use the <code>list()</code> function that allows to store objects of different nature (e.g. scalars, vectors, matrices) as elements of a single object while assigning names to them. For example, the estimated parameter <span class="math inline">\(\beta\)</span> will be accessible through the element name <code>beta</code> (we’ll see how this done further on).</p>
<p>Nevertheless, in order to answer the question of our example on the Hubble constant, we would need to obtain a confidence interval for our estimated paramter <span class="math inline">\(\hat{\beta}\)</span>. Although the information needed for this purpose is available to the user through the current output, it may be useful to directly provide the confidence interval since it is a piece of information which is almost always required to deliver inference on the true parameter <span class="math inline">\(\beta\)</span>. Let us therefore build a confidence interval within our function for which we will assume that the estimated variance of <span class="math inline">\(\hat{\beta}\)</span> is actually the true variance (otherwise we would need to build a confidence interval based on the Student-t distribution which we will not deal with at this stage of our course). Assuming therefore that</p>
<span class="math display">\[\begin{equation*}
  \hat{\beta} \sim \mathcal{N}\left(\beta,\hat{\sigma}^2(X^TX)^{-1}\right) ,
\end{equation*}\]</span>
<p>we consequently have that the confidence interval is given by</p>
<span class="math display" id="eq:cibeta">\[\begin{equation}
  \left[\hat{\beta} - z_{1-\alpha/2}\sqrt{\hat{\sigma}^2(X^TX)^{-1}} \, , \, \hat{\beta} + z_{1-\alpha/2}\sqrt{\hat{\sigma}^2(X^TX)^{-1}} \right] ,
  \tag{6.4}
\end{equation}\]</span>
<p>where <span class="math inline">\(z_{1-\alpha/2}\)</span> is the <span class="math inline">\((1-\alpha/2)^{th}\)</span> quantile of the standard normal distribution.</p>
<p>Let us therefore add this output to our function which would require an extra argument: the confidence level. The most common confidence level used is the 95% level which is obtained by defining the significance level <span class="math inline">\(\alpha = 0.05\)</span>. We could therefore add the latter argument to our function and set its default value to 0.05.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_lm =<span class="st"> </span>function(response, covariates, <span class="dt">alpha =</span> <span class="fl">0.05</span>) {
  
  <span class="co"># Make sure data formats are appropriate</span>
  response &lt;-<span class="st"> </span><span class="kw">as.vector</span>(response)
  covariates &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(covariates)
  
  <span class="co"># Define parameters</span>
  n &lt;-<span class="st"> </span><span class="kw">length</span>(response)
  p &lt;-<span class="st"> </span><span class="kw">dim</span>(covariates)[<span class="dv">2</span>]
  df &lt;-<span class="st"> </span>n -<span class="st"> </span>p
  
  <span class="co"># Estimate beta through Eq. (1.1)</span>
  beta.hat &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)%*%<span class="kw">t</span>(covariates)%*%response
  
  <span class="co"># Estimate of the residual variance (sigma2) from Eq. (1.3)</span>
  resid &lt;-<span class="st"> </span>response -<span class="st"> </span>covariates%*%<span class="kw">as.matrix</span>(beta.hat) <span class="co"># compute residuals</span>
  sigma2.hat &lt;-<span class="st"> </span>(<span class="dv">1</span>/df)*<span class="kw">t</span>(resid)%*%resid
  
  <span class="co"># Estimate of the variance of the estimated beta from Eq. (1.2)</span>
  var.beta &lt;-<span class="st"> </span>sigma2.hat*<span class="kw">solve</span>(<span class="kw">t</span>(covariates)%*%covariates)
  
  <span class="co"># Estimate of the confidence interval based on alpha</span>
  quant &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>alpha/<span class="dv">2</span>
  ci.beta &lt;-<span class="st"> </span><span class="kw">c</span>(beta.hat -<span class="st"> </span><span class="kw">qnorm</span>(<span class="dt">p =</span> quant)*<span class="kw">sqrt</span>(var.beta), beta.hat +<span class="st"> </span>
<span class="st">                 </span><span class="kw">qnorm</span>(<span class="dt">p =</span> quant)*<span class="kw">sqrt</span>(var.beta))
  
  <span class="co"># Return all estimated values</span>
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">beta =</span> beta.hat, <span class="dt">sigma2 =</span> sigma2.hat, <span class="dt">variance_beta =</span> var.beta, <span class="dt">ci =</span> ci.beta))
  
}</code></pre></div>
<p>We now have now a general function to perform linear regression which has a series of scalar outputs as well as a vector (i.e. the confidence interval). We will proceed to comparing the outputs of our function with those of the <code>lm()</code> function in base R but, before doing so, the next section will briefly discuss the third component of an R function which is its environment.</p>
</div>
</div>
<div id="function-environment" class="section level2">
<h2><span class="header-section-number">6.3</span> Function environment</h2>
<p>Generally speaking, an environment is a virtual space in which certain names are associated to specific objects and values. The main characterstics of an environment are the following (see Wickham <a href="http://adv-r.had.co.nz/Environments.html">Environments</a>):</p>
<ul>
<li>Every name in an environment is unique</li>
<li>Every environment has a parent</li>
</ul>
<p>The second characteristic means that when working within a given environment, you’re also working in an environment (parent) which includes that environment. For example, in R the usual environment one works in is the “global environment” and its parent is the last package that has been loaded in the R session while the “base environment” is a special case of the global environment and is the environment of the base package (whose parent is the empty environment).</p>
<p>Within this structure, also functions have their own types of environments. Based on this structure, functions will look for the names of objects (and associated values) through scoping methods that start within the function’s environment and then, if these are not found, proceed to looking for the names in the parent environments. The types of environments for R functions are the following:</p>
<ul>
<li>Enclosing: this is the environment in which the function was created (usually the global environment) and each function only has one enclosing environment</li>
<li>Binding: this is the environment in which the function is associated to a given name (usually the enclosing and binding environment are the same)</li>
<li>Execution: this environment is created each time a function is called and in which the objects created by this function during execution are stored</li>
<li>Calling: this environment is associated with the execution environment and reports the environment in which a function was called</li>
</ul>
<p>First of all, the enclosing environment of a function can be found by using the <code>environment()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">environment</span>(my_lm)</code></pre></div>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>With this function therefore informs the user on the enclosing environment and its main difference with the binding environment consists in the fact that the first determines how to find values (lexical scoping) while the second determines how to find the function. The reason for this separation (at least one of the main reasons) lies in the need to separate package namespaces. By the latter we mean, for example, the case where packages have the same names for different functions, allowing to preserve the name of the function in the enclosing environment unless otherwise specified. An example can be given with the <code>var()</code> function (to compute the variance) which uses the <code>missing()</code> function (in the base package) to check if a value is specified as an argument to a function (check with <code>?missing</code>). Let us suppose we compute the variance of a vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">9</span>)
<span class="kw">var</span>(x)</code></pre></div>
<pre><code>## [1] 6.8</code></pre>
<p>Let us now create another function called <code>missing</code> in the global environment which takes <code>x</code> as an argument but only returns 100. After this, we execute the code above again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">missing =<span class="st"> </span>function (x) <span class="dv">100</span>
x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">9</span>)
<span class="kw">var</span>(x)</code></pre></div>
<pre><code>## [1] 6.8</code></pre>
<p>The result is always the same although the <code>var()</code> function would have halted execution if it had considered our own <code>missing()</code> function. This is possible thanks the to the package namespace which keeps packages independent through the separate use of enclosing and binding environments.</p>
<p>Finally, the execution environment allows to create a temporary environment in which the function can create its objects without affecting the environment in which it is created and called. For example, suppose that we call our <code>my_lm</code> function but, before doing so, we define an object called <code>quant</code> and assign a value to it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quant &lt;-<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>We know that our <code>my_lm()</code> function creates an object with the same name and, according to standard R programming rules, the new object with the same name should overwrite the previous one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit &lt;-<span class="st"> </span><span class="kw">my_lm</span>(<span class="kw">rnorm</span>(<span class="dv">100</span>), <span class="kw">rnorm</span>(<span class="dv">100</span>))
quant</code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>As can be seen, although our <code>my_lm()</code> function defines <code>quant &lt;- 1 - alpha/2</code>, this quantity remains in the execution environment and does not affect or modify the environment in which is it called (calling environment) since its parent is the enclosing environment and is removed once the function has completed execution.</p>
</div>
<div id="example-continued-function-comparison-and-hypothesis-testing" class="section level2">
<h2><span class="header-section-number">6.4</span> Example (continued): function comparison and hypothesis testing</h2>
<p>Having given an overview of the main components to a function in R, let us now complete this chapter by investigating how the <code>my_lm()</code> function performs compared to the base <code>lm()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Linear regression with lm() function</span>
fit_lm =<span class="st"> </span><span class="kw">lm</span>(hubble$y~hubble$x<span class="dv">-1</span>)

<span class="co"># Linear regression with my_lm() function</span>
fit_my_lm =<span class="st"> </span><span class="kw">my_lm</span>(hubble$y, hubble$x)

<span class="co"># Compare outputs</span>
manual_results =<span class="st"> </span><span class="kw">c</span>(fit_my_lm$beta, fit_my_lm$sigma2)
base_results =<span class="st"> </span><span class="kw">c</span>(fit_lm$coefficients, 
                     (<span class="dv">1</span>/fit_lm$df.residual)*<span class="kw">t</span>(fit_lm$residuals)%*%fit_lm$residuals)
results =<span class="st"> </span><span class="kw">cbind</span>(manual_results, base_results)
<span class="kw">row.names</span>(results) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Beta&quot;</span>, <span class="st">&quot;Sigma&quot;</span>)
results</code></pre></div>
<pre><code>##       manual_results base_results
## Beta        76.58117     76.58117
## Sigma    67046.33165  67046.33165</code></pre>
<p>As one can notice, the two procedures give the same outputs indicating that our <code>my_lm()</code> function well implements the linear regression method. We can now proceed to use our function in order to test the Creationist hypothesis on the age of the universe assuming the validity of the big bang theory. First of all, due to different measurement units we perform a unit transformation and then compute the age in years (which requires an additional transformation since the previous one gives a unit of <span class="math inline">\(s^{-1}\)</span>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hubble.const &lt;-<span class="st"> </span>fit_my_lm$beta/<span class="fl">3.09e19</span> <span class="co"># Estimated Hubble&#39;s constant in inverse seconds</span>
age.sec &lt;-<span class="st"> </span><span class="dv">1</span>/hubble.const <span class="co"># Age of the universe in seconds</span>
age.sec/(<span class="dv">60</span>^<span class="dv">2</span>*<span class="dv">24</span>*<span class="dv">365</span>) <span class="co"># Age of the universe in years</span></code></pre></div>
<p>Based on this estimation, the age of the universe appears to be almost 13 billion years. However, we know that <span class="math inline">\(\hat{\beta}\)</span> is a random variable that therefore follows a distribution which, based on asymptotic statistical theory, is a normal distribution with expectaton <span class="math inline">\(\beta\)</span> and variance <span class="math inline">\(\sigma^2(X^TX)^{-1}\)</span>.</p>
<p>Now, let’s suppose that we have a hypothesis on the age of the universe, for example that of Creation Scientists who claim that the universe is 6000 years old based on a reading from the Bible. Assuming the validity of the big bang theory, which is not the case for Creation Scientists, let us nevertheless test if their claim appears to be reasonable within this postulated framework. For this purpose we can build a 95% confidence interval for the true Hubble constant <span class="math inline">\(\beta\)</span> and understand if the Hubble constant implied by the postulated age of the universe falls within this interval. Firstly, we can determine this constant under the null hypothesis which can be defined as follows</p>
<span class="math display">\[\begin{equation*}
  H_0 \, : \, \beta = 163 \times 10^6 ,
\end{equation*}\]</span>
<p>since this value of <span class="math inline">\(\beta\)</span> would imply that the universe is roughly 6000 years old. The alternative hypothesis is that the true <span class="math inline">\(\beta\)</span> is not equal to the above quantity (i.e. <span class="math inline">\(H_A \, : \, \beta \neq 163 \times 10^6\)</span>). … Let us therefore replace the values in Eq. <a href="functions.html#eq:cibeta">(6.4)</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 95% confidence interval for the Hubble constant</span>
fit_my_lm$ci</code></pre></div>
<pre><code>## [1] 68.81032 84.35203</code></pre>
<p>The confidence interval lies between 68 and 84 which clearly does not contain the value implied by the age of the universe postulated by the Creation Scientists. Hence, assuming the validity of the big bang theory, we can reject this hypothesis at a 95% level.</p>

</div>
</div>
<h3> Placeholder</h3>
<div id="refs" class="references">
<div id="ref-wood2017generalized">
<p>Wood, Simon N. 2017. <em>Generalized Additive Models: An Introduction with R</em>. CRC press.</p>
</div>
<div id="ref-seber2012linear">
<p>Seber, George AF, and Alan J Lee. 2012. <em>Linear Regression Analysis</em>. Vol. 936. John Wiley &amp; Sons.</p>
</div>
<div id="ref-wickham2014advanced">
<p>Wickham, Hadley. 2014. <em>Advanced R</em>. CRC Press. <a href="http://adv-r.had.co.nz/" class="uri">http://adv-r.had.co.nz/</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="control.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="placeholder.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/05-functions.Rmd",
"text": "Edit"
},
"download": ["ds.pdf", "ds.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
