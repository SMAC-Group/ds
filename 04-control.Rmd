# Control Flow {#control}

## Introduction

When you are building a larger program than the examples we considered previously, we need use various **control structures** to control the "flow" of our actions. Essentially, a control structure is "block" of code that analyzes variables and chooses a direction in which to go based on given parameters. These pieces of code represent the most basic decision-making process in computing. There exist essentially two kinds of control structures. The first ones allow to assess whether a given condition is satisfied and take appropriate in response. A simple analogy to our day to day life would be "**if** it raining outside **then** take an umbrella", we will come back to this example later in this chapter. The second kind of control structures allow to repeat of a block code multiple times. For example such approach can be used to convert a color image to gray-scale by applying the same operation(s) (i.e. same code) to each pixel of the image. In this chapter, we will first discuss the two kind control structures previously mentioned and then present various example to build our intuition.

<!-- Just like in our daily life, we need to place conditions in which we manipulate our behavior. Statistical programming also fundamentally works in the same way. We program specific behaviors for the program to follow to obtain the statistics that we may need for various tasks like regression and bootstrapping. -->


## Selection Operators

Suppose that we are interested in creating a simple code to check if it rained in last hour and this is the case to let us that we should probably take an umbrella today. To write such a code we essentially need three things:

1) Find out how much it rained in the last hour at our location. Such information is now easily accessible through various websites and we can for example used the R package `rwunderground` to access this information. Note that you will need to create an account and request an API key before being able to use it (see [package documentation](https://cran.r-project.org/web/packages/rwunderground/rwunderground.pdf) for more details). Then, the precipitation amount (in inch) in the last hour can be retrieve using the code below: 

```{r, warning=FALSE, message=FALSE}
library(rwunderground)
(rain <- conditions(set_location(zip_code = "16802"), message = FALSE)$precip_1hr)
```

2) Construct a logical (or boolean) variable created from the variable `rain` to assess whether or a umbrella is need. For example we could judged that there was any water in the last hour we should take an umbrella. This can be done as in the code below and in Section \@ref(logical_operators) we will discuss how to construct logical variables in more details.

```{r}
(umbrella <- rain > 0)
```

3) Finally, we need to selection operator based on the logical variable constructed in the previous step to bring everything together. For example, we could the `if/else` statement presented below. This simple code will print "*You should probably take an umbrella*" is the logical variable `umbrella` is `TRUE` and print "*An umbrella is probably not necessary*", otherwise.

```{r}
if (umbrella){
  print("You should probably take an umbrella")
}else{
  print("An umbrella is probably not necessary")
}
```


### Logical Operators {#sec_logical}

Logical operators are used very commonly used in programming to create (or return) logical (Boolean) variables. In general, logical operations take place by comparing one or more variables following specific rules. 

```{r}
x <- 4
y <- 2
```


| Command     | Description                |   Example                           |    Result                             |
|-------------|----------------------------|-------------------------------------|---------------------------------------|
| x `>` y     | x greater than y           | `4 > 3`                             | `r 4 > 3`                             |
| x `>=` y    | x greater or equals to y   | `1 >= 1`                            | `r 1 >= 1`                            |
| x `<` y     | x less than y              | `c(12 < 20, 1 < 1)`                 | `r c(12 < 20, 1 < 1)`                 |
| x `<=` y    | x less than or equals to y | `12 <= 1`                           | `r 12 <= 1`                           |
| x `==` y    | x equal to y               | `c(2 == 2, 1 == 2)`                 | `r c(2 == 2, 1 == 2)`                 |
| x `!=` y    | x not equal to y           | `c(2 != 2, F != T)`                 | `r c(2 != 2, FALSE != TRUE)`          |
| `!`x        | Not x                      | `c(!(2 > 1), !FALSE)`               | `r c(!(2 > 1), !FALSE)`               |
| x `|| `y    | x or y (not vectorized)    | `(1 > 1) || (2 < 3)`                | `r (1 > 1) || (2 < 3)`                |
| x `| `y     | x or y (vectorized)        | `c(1 > 1, F) || c(T, 2 < 3)`        | `r c(1 > 1, F) || c(T, 2 < 3)`        |
| x `&&` y    | x and y (not vectorized)   | `TRUE && TRUE`                      | `r TRUE && TRUE`                      |
| x `&` y     | x and y (vectorized)       | `c(TRUE, T) & c(TRUE, F)`           | `r c(TRUE, T) & c(TRUE, F)`           |
| xor(x,y)    | test if only one is TRUE   | `xor(TRUE, TRUE)`                   | `r xor(TRUE, TRUE)`                   |
| `all`(x)    | test if all are TRUE       |  `all(c(T, F, F))`                  | `r all(c(T, F, F))`                   |
| `any`(x)    | test if one or more is TRUE|  `any(c(T, F, F))`                  | `r any(c(T, F, F))`                   |

Logical operators can be applied to vectors as well. For example, here we create two random numerical vectors and compare them. 

```{r, eval = FALSE}
2 = 2
c(TRUE,FALSE) || c(FALSE, FALSE)
```

```{r}
x = c(3,6,3,4,5)
y = c(2,3,4,5,6)
x>y
```

This method outputs a vector of boolean TRUE and FALSE values that perform element-wise comparisons. Note, this is called a vectorized method, which we will further mention in some detail later. `isTRUE()` checks if all the elements within the object is `TRUE`. 

```{r}
isTRUE(TRUE)
isTRUE(x>y)
```

